{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///optimal-select.min.js","webpack:///webpack/bootstrap 31e8eb15010e94eb2118","webpack:///./src/common.js","webpack:///./src/utilities.js","webpack:///./src/optimize.js","webpack:///./src/adapt.js","webpack:///./src/select.js","webpack:///./~/css2xpath/index.js","webpack:///./~/sizzle/dist/sizzle.js","webpack:///./src/match.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","getSelect","arguments","length","undefined","format","Sizzle","selector","parent","document","querySelectorAll","getCommonAncestor","elements","options","_options$root","ancestors","forEach","element","index","parents","parentNode","unshift","sort","curr","next","shallowAncestor","shift","ancestor","_loop","some","otherParents","otherParent","getCommonProperties","commonProperties","classes","attributes","tag","commonClasses","commonAttributes","commonTag","getAttribute","trim","split","filter","entry","elementAttributes","keys","reduce","key","attribute","attributeName","attributesNames","commonAttributesNames","nextCommonAttributes","tagName","toLowerCase","convertNodeList","nodes","arr","Array","escapeValue","replace","_interopRequireDefault","obj","default","optimize","startsWith","isArray","_utilities","nodeType","Error","select","_adapt2","_common","path","match","optimizePart","shortened","pop","current","prePart","join","postPart","pattern","matches","every","slice","test","compareResults","references","_loop2","reference","contains","description","pattern2","matches2","_ret2","descendant","pattern3","type","pattern4","names","map","partial","pattern5","charAt","_loop3","i2","pattern6","matches6","l2","_ret3","_adapt","adapt","sliceIterator","_arr","_n","_d","_e","_s","_i","Symbol","iterator","done","push","err","getSingleSelector","_typeof","_match2","_optimize2","getMultiSelector","ancestorSelector","commonSelectors","getCommonSelectors","descendantSelector","selectorMatches","console","warn","_getCommonProperties","selectorPath","classSelector","attributeSelector","parts","getQuerySelector","input","result","includes","_css2xpath2","constructor","_css2xpath","_match","_optimize","prependAxis","axis","regex_first_axis","start","literal","substr","selectorStart","depth","offset","escape_parens","isNumeric","num","parseInt","isNaN","escapeChar","open","close","char","RegExp","a","repeat","str","Number","convertEscaping","css2xpath","nested","css_pseudo_classes_regex","css_pseudo_classes_callback","css_ids_classes_regex","css_ids_classes_callback","literals","regex_string_literal","escape_literal","css_combinators_regex","css_combinators_callback","css_attributes_regex","css_attributes_callback","search","regex_css_wrap_pseudo","indexOf","substring","regex_escaped_literal","regex_specal_chars","regex_filter_prefix","regex_attr_prefix","xpath_to_lower","xpath_ends_with","s1","s2","xpath_url","xpath_url_attrs","xpath_url_path","xpath_url_domain","xpath_lower_case","xpath_ns_uri","xpath_ns_path","xpath_has_protocal","xpath_is_internal","xpath_normalize_space","xpath_internal","xpath_external","String","fromCharCode","regex_nth_equation","operator","func","exclude","orig","prefix","prevChar","attr","comp","op","val","g1","g2","arg","g3","g4","g5","xpath","window","__WEBPACK_AMD_DEFINE_RESULT__","context","results","seed","elem","nid","groups","newSelector","newContext","ownerDocument","setDocument","documentIsHTML","rquickExpr","exec","getElementById","id","apply","getElementsByTagName","support","getElementsByClassName","qsa","nonnativeSelectorCache","rbuggyQSA","nodeName","rdescend","rcombinators","rsibling","testContext","scope","rcssescape","fcssescape","setAttribute","expando","tokenize","toSelector","qsaError","removeAttribute","rtrim","createCache","cache","Expr","cacheLength","markFunction","fn","assert","el","createElement","e","removeChild","addHandle","attrs","handler","attrHandle","siblingCheck","b","cur","diff","sourceIndex","nextSibling","createInputPseudo","createButtonPseudo","createDisabledPseudo","disabled","isDisabled","inDisabledFieldset","createPositionalPseudo","argument","j","matchIndexes","setFilters","tokens","len","addCombinator","matcher","combinator","base","dir","skip","checkNonElements","doneName","first","xml","oldCache","uniqueCache","outerCache","newCache","dirruns","uniqueID","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","temp","preMap","postMap","preexisting","elems","matcherIn","matcherOut","splice","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","ret","outermostContext","concat","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","find","dirrunsUnique","Math","random","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","Date","preferredDoc","classCache","tokenCache","compilerCache","sortOrder","hasOwn","pushNative","list","booleans","whitespace","identifier","pseudos","rwhitespace","rcomma","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rhtml","rinputs","rheader","rnative","runescape","funescape","escape","nonHex","high","ch","asCodePoint","charCodeAt","toString","unloadHandler","childNodes","target","els","namespace","namespaceURI","documentElement","node","hasCompare","subWindow","doc","defaultView","top","addEventListener","attachEvent","appendChild","className","createComment","getById","getElementsByName","attrId","getAttributeNode","tmp","innerHTML","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","expr","specified","sel","error","msg","duplicates","detectDuplicates","sortStable","textContent","firstChild","nodeValue","selectors","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","check","what","_argument","last","simple","forward","ofType","_context","nodeIndex","useCache","lastChild","pseudo","args","idx","matched","not","has","text","lang","elemLang","hash","location","focus","activeElement","hasFocus","href","tabIndex","enabled","checked","selected","selectedIndex","empty","header","button","_matchIndexes","eq","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","_name","defaultValue","_sizzle","noConflict","_toConsumableArray","arr2","from","_options$skip","_options$priority","priority","_options$ignore","ignore","jquery","skipCompare","skipChecks","predicate","checkAttributes","checkTag","checkContains","checkChilds","findPattern","findAttributesPattern","getClassSelector","r","attributeNames","sortedKeys","attributeValue","useNamedIgnore","currentIgnore","currentDefaultIgnore","defaultIgnore","checkIgnore","classNames","classIgnore","class","findTagPattern","children","childTags","child","childPattern","elementPattern","defaultPredicate","_interopRequireWildcard","newObj","common","_select","_common2"],"mappings":"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","file":"optimal-select.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSelect = getSelect;\nexports.getCommonAncestor = getCommonAncestor;\nexports.getCommonProperties = getCommonProperties;\n/**\n * # Common\n *\n * Process collections for similarities.\n */\n\n/**\n * Query document using correct selector\n *\n * @param  {Object}               options - [description]\n * @return {(selector: string, parent: HTMLElement) => Array.<HTMLElements>} - [description]\n */\nfunction getSelect() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (options.format === 'jquery') {\n    var Sizzle = __webpack_require__(6);\n    return function (selector) {\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      return Sizzle(selector, parent || document);\n    };\n  }\n  return function (selector) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    return (parent || document).querySelectorAll(selector);\n  };\n}\n\n/**\n * Find the last common ancestor of elements\n *\n * @param  {Array.<HTMLElements>} elements - [description]\n * @return {HTMLElement}                   - [description]\n */\nfunction getCommonAncestor(elements) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$root = options.root,\n      root = _options$root === undefined ? document : _options$root;\n\n\n  var ancestors = [];\n\n  elements.forEach(function (element, index) {\n    var parents = [];\n    while (element !== root) {\n      element = element.parentNode;\n      parents.unshift(element);\n    }\n    ancestors[index] = parents;\n  });\n\n  ancestors.sort(function (curr, next) {\n    return curr.length - next.length;\n  });\n\n  var shallowAncestor = ancestors.shift();\n\n  var ancestor = null;\n\n  var _loop = function _loop() {\n    var parent = shallowAncestor[i];\n    var missing = ancestors.some(function (otherParents) {\n      return !otherParents.some(function (otherParent) {\n        return otherParent === parent;\n      });\n    });\n\n    if (missing) {\n      // TODO: find similar sub-parents, not the top root, e.g. sharing a class selector\n      return 'break';\n    }\n\n    ancestor = parent;\n  };\n\n  for (var i = 0, l = shallowAncestor.length; i < l; i++) {\n    var _ret = _loop();\n\n    if (_ret === 'break') break;\n  }\n\n  return ancestor;\n}\n\n/**\n * Get a set of common properties of elements\n *\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Object}                       - [description]\n */\nfunction getCommonProperties(elements) {\n\n  var commonProperties = {\n    classes: [],\n    attributes: {},\n    tag: null\n  };\n\n  elements.forEach(function (element) {\n    var commonClasses = commonProperties.classes,\n        commonAttributes = commonProperties.attributes,\n        commonTag = commonProperties.tag;\n\n    // ~ classes\n\n    if (commonClasses !== undefined) {\n      var classes = element.getAttribute('class');\n      if (classes) {\n        classes = classes.trim().split(' ');\n        if (!commonClasses.length) {\n          commonProperties.classes = classes;\n        } else {\n          commonClasses = commonClasses.filter(function (entry) {\n            return classes.some(function (name) {\n              return name === entry;\n            });\n          });\n          if (commonClasses.length) {\n            commonProperties.classes = commonClasses;\n          } else {\n            delete commonProperties.classes;\n          }\n        }\n      } else {\n        // TODO: restructure removal as 2x set / 2x delete, instead of modify always replacing with new collection\n        delete commonProperties.classes;\n      }\n    }\n\n    // ~ attributes\n    if (commonAttributes !== undefined) {\n      var elementAttributes = element.attributes;\n      var attributes = Object.keys(elementAttributes).reduce(function (attributes, key) {\n        var attribute = elementAttributes[key];\n        var attributeName = attribute.name;\n        // NOTE: workaround detection for non-standard phantomjs NamedNodeMap behaviour\n        // (issue: https://github.com/ariya/phantomjs/issues/14634)\n        if (attribute && attributeName !== 'class') {\n          attributes[attributeName] = attribute.value;\n        }\n        return attributes;\n      }, {});\n\n      var attributesNames = Object.keys(attributes);\n      var commonAttributesNames = Object.keys(commonAttributes);\n\n      if (attributesNames.length) {\n        if (!commonAttributesNames.length) {\n          commonProperties.attributes = attributes;\n        } else {\n          commonAttributes = commonAttributesNames.reduce(function (nextCommonAttributes, name) {\n            var value = commonAttributes[name];\n            if (value === attributes[name]) {\n              nextCommonAttributes[name] = value;\n            }\n            return nextCommonAttributes;\n          }, {});\n          if (Object.keys(commonAttributes).length) {\n            commonProperties.attributes = commonAttributes;\n          } else {\n            delete commonProperties.attributes;\n          }\n        }\n      } else {\n        delete commonProperties.attributes;\n      }\n    }\n\n    // ~ tag\n    if (commonTag !== undefined) {\n      var tag = element.tagName.toLowerCase();\n      if (!commonTag) {\n        commonProperties.tag = tag;\n      } else if (tag !== commonTag) {\n        delete commonProperties.tag;\n      }\n    }\n  });\n\n  return commonProperties;\n}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertNodeList = convertNodeList;\nexports.escapeValue = escapeValue;\n/**\n * # Utilities\n *\n * Convenience helpers.\n */\n\n/**\n * Create an array with the DOM nodes of the list\n *\n * @param  {NodeList}             nodes - [description]\n * @return {Array.<HTMLElement>}        - [description]\n */\nfunction convertNodeList(nodes) {\n  var length = nodes.length;\n\n  var arr = new Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = nodes[i];\n  }\n  return arr;\n}\n\n/**\n * Escape special characters and line breaks as a simplified version of 'CSS.escape()'\n *\n * Description of valid characters: https://mathiasbynens.be/notes/css-escapes\n *\n * @param  {String?} value - [description]\n * @return {String}        - [description]\n */\nfunction escapeValue(value) {\n  return value && value.replace(/['\"`\\\\/:?&!#$%^()[\\]{|}*+;,.<=>@~]/g, '\\\\$&').replace(/\\n/g, '\\xA0');\n}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = optimize;\n\nvar _adapt = __webpack_require__(3);\n\nvar _adapt2 = _interopRequireDefault(_adapt);\n\nvar _common = __webpack_require__(0);\n\nvar _utilities = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Apply different optimization techniques\n *\n * @param  {string}                          selector - [description]\n * @param  {HTMLElement|Array.<HTMLElement>} element  - [description]\n * @param  {Object}                          options  - [description]\n * @return {string}                                   - [description]\n */\nfunction optimize(selector, elements) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\n  if (selector.startsWith('> ')) {\n    selector = selector.replace('> ', '');\n  }\n\n  // convert single entry and NodeList\n  if (!Array.isArray(elements)) {\n    elements = !elements.length ? [elements] : (0, _utilities.convertNodeList)(elements);\n  }\n\n  if (!elements.length || elements.some(function (element) {\n    return element.nodeType !== 1;\n  })) {\n    throw new Error('Invalid input - to compare HTMLElements its necessary to provide a reference of the selected node(s)! (missing \"elements\")');\n  }\n\n  var globalModified = (0, _adapt2.default)(elements[0], options);\n  var select = (0, _common.getSelect)(options);\n\n  // chunk parts outside of quotes (http://stackoverflow.com/a/25663729, https://stackoverflow.com/a/16261693)\n  // var path = selector.replace(/> /g, '>').split(/\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)\n  var path = selector.replace(/> /g, '>').match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n\n  if (path.length < 2) {\n    return optimizePart('', selector, '', elements, select);\n  }\n\n  var shortened = [path.pop()];\n\n  var _loop = function _loop() {\n    var current = path.pop();\n    var prePart = path.join(' ');\n    var postPart = shortened.join(' ');\n\n    var pattern = prePart + ' ' + postPart;\n    var matches = select(pattern);\n    var hasSameResult = matches.length === elements.length && elements.every(function (element, i) {\n      return element === matches[i];\n    });\n    if (!hasSameResult) {\n      shortened.unshift(optimizePart(prePart, current, postPart, elements, select));\n    }\n  };\n\n  while (path.length > 1) {\n    _loop();\n  }\n  shortened.unshift(path[0]);\n  path = shortened;\n\n  // optimize start + end\n  path[0] = optimizePart('', path[0], path.slice(1).join(' '), elements, select);\n  path[path.length - 1] = optimizePart(path.slice(0, -1).join(' '), path[path.length - 1], '', elements, select);\n\n  if (globalModified) {\n    delete true;\n  }\n\n  return path.join(' ').replace(/>/g, '> ').trim();\n}\n\n/**\n * Improve a chunk of the selector\n *\n * @param  {string}              prePart  - [description]\n * @param  {string}              current  - [description]\n * @param  {string}              postPart - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @return {string}                       - [description]\n */\n/**\n * # Optimize\n *\n * 1.) Improve efficiency through shorter selectors by removing redundancy\n * 2.) Improve robustness through selector transformation\n */\n\nfunction optimizePart(prePart, current, postPart, elements, select) {\n  if (prePart.length) prePart = prePart + ' ';\n  if (postPart.length) postPart = ' ' + postPart;\n\n  // can't optimize jquery expression\n  if (/:contains\\(/.test(current)) {\n    return current;\n  }\n\n  // robustness: attribute without value (generalization)\n  if (/\\[*\\]/.test(current)) {\n    var key = current.replace(/=.*$/, ']');\n    var pattern = '' + prePart + key + postPart;\n    var matches = select(pattern);\n    if (compareResults(matches, elements)) {\n      current = key;\n    } else {\n      // robustness: replace specific key-value with base tag (heuristic)\n      var references = select('' + prePart + key);\n\n      var _loop2 = function _loop2() {\n        var reference = references[i];\n        if (elements.some(function (element) {\n          return reference.contains(element);\n        })) {\n          var description = reference.tagName.toLowerCase();\n          pattern2 = '' + prePart + description + postPart;\n          matches2 = select(pattern2);\n\n          if (compareResults(matches2, elements)) {\n            current = description;\n          }\n          return 'break';\n        }\n      };\n\n      for (var i = 0, l = references.length; i < l; i++) {\n        var pattern2;\n        var matches2;\n\n        var _ret2 = _loop2();\n\n        if (_ret2 === 'break') break;\n      }\n    }\n  }\n\n  // robustness: descendant instead child (heuristic)\n  if (/>/.test(current)) {\n    var descendant = current.replace(/>/, '');\n    var pattern3 = '' + prePart + descendant + postPart;\n    var matches3 = select(pattern3);\n    if (compareResults(matches3, elements)) {\n      current = descendant;\n    }\n  }\n\n  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n  if (/:nth-child/.test(current)) {\n    // TODO: consider complete coverage of 'nth-of-type' replacement\n    var type = current.replace(/nth-child/g, 'nth-of-type');\n    var pattern4 = '' + prePart + type + postPart;\n    var matches4 = select(pattern4);\n    if (compareResults(matches4, elements)) {\n      current = type;\n    }\n  }\n\n  // efficiency: combinations of classname (partial permutations)\n  if (/^\\.\\S*[^\\s\\\\]\\.\\S+/.test(current)) {\n    var names = current.trim().replace(/(^|[^\\\\])\\./g, '$1#.') // escape actual dots\n    .split('#.') // split only on actual dots\n    .slice(1).map(function (name) {\n      return '.' + name;\n    }).sort(function (curr, next) {\n      return curr.length - next.length;\n    });\n    while (names.length) {\n      var partial = current.replace(names.shift(), '').trim();\n      var pattern5 = ('' + prePart + partial + postPart).trim();\n      if (!pattern5.length || pattern5.charAt(0) === '>' || pattern5.charAt(pattern5.length - 1) === '>') {\n        break;\n      }\n      var matches5 = select(pattern5);\n      if (compareResults(matches5, elements)) {\n        current = partial;\n      }\n    }\n\n    // robustness: degrade complex classname (heuristic)\n    names = current && current.match(/\\./g);\n    if (names && names.length > 2) {\n      var _references = select('' + prePart + current);\n\n      var _loop3 = function _loop3() {\n        var reference = _references[i2];\n        if (elements.some(function (element) {\n          return reference.contains(element);\n        })) {\n          // TODO:\n          // - check using attributes + regard excludes\n          var description = reference.tagName.toLowerCase();\n          pattern6 = '' + prePart + description + postPart;\n          matches6 = select(pattern6);\n\n          if (compareResults(matches6, elements)) {\n            current = description;\n          }\n          return 'break';\n        }\n      };\n\n      for (var i2 = 0, l2 = _references.length; i2 < l2; i2++) {\n        var pattern6;\n        var matches6;\n\n        var _ret3 = _loop3();\n\n        if (_ret3 === 'break') break;\n      }\n    }\n  }\n\n  return current;\n}\n\n/**\n * Evaluate matches with expected elements\n *\n * @param  {Array.<HTMLElement>} matches  - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Boolean}                      - [description]\n */\nfunction compareResults(matches, elements) {\n  var length = matches.length;\n\n  return length === elements.length && elements.every(function (element) {\n    for (var i = 0; i < length; i++) {\n      if (matches[i] === element) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\nmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = adapt;\n/**\n * # Adapt\n *\n * Check and extend the environment for universal usage.\n */\n\n/**\n * Modify the context based on the environment\n *\n * @param  {HTMLELement} element - [description]\n * @param  {Object}      options - [description]\n * @return {boolean}             - [description]\n */\nfunction adapt(element, options) {\n  // detect environment setup\n  if (true) {\n    return false;\n  } else {\n    global.document = options.context || function () {\n      var root = element;\n      while (root.parent) {\n        root = root.parent;\n      }\n      return root;\n    }();\n  }\n\n  // https://github.com/fb55/domhandler/blob/master/index.js#L75\n  var ElementPrototype = Object.getPrototypeOf(true);\n\n  // alternative descriptor to access elements with filtering invalid elements (e.g. textnodes)\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'childTags')) {\n    Object.defineProperty(ElementPrototype, 'childTags', {\n      enumerable: true,\n      get: function get() {\n        return this.children.filter(function (node) {\n          // https://github.com/fb55/domelementtype/blob/master/index.js#L12\n          return node.type === 'tag' || node.type === 'script' || node.type === 'style';\n        });\n      }\n    });\n  }\n\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'attributes')) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes\n    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap\n    Object.defineProperty(ElementPrototype, 'attributes', {\n      enumerable: true,\n      get: function get() {\n        var attribs = this.attribs;\n\n        var attributesNames = Object.keys(attribs);\n        var NamedNodeMap = attributesNames.reduce(function (attributes, attributeName, index) {\n          attributes[index] = {\n            name: attributeName,\n            value: attribs[attributeName]\n          };\n          return attributes;\n        }, {});\n        Object.defineProperty(NamedNodeMap, 'length', {\n          enumerable: false,\n          configurable: false,\n          value: attributesNames.length\n        });\n        return NamedNodeMap;\n      }\n    });\n  }\n\n  if (!ElementPrototype.getAttribute) {\n    // https://docs.webplatform.org/wiki/dom/Element/getAttribute\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute\n    ElementPrototype.getAttribute = function (name) {\n      return this.attribs[name] || null;\n    };\n  }\n\n  if (!ElementPrototype.getElementsByTagName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByTagName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\n    ElementPrototype.getElementsByTagName = function (tagName) {\n      var HTMLCollection = [];\n      traverseDescendants(this.childTags, function (descendant) {\n        if (descendant.name === tagName || tagName === '*') {\n          HTMLCollection.push(descendant);\n        }\n      });\n      return HTMLCollection;\n    };\n  }\n\n  if (!ElementPrototype.getElementsByClassName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByClassName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\n    ElementPrototype.getElementsByClassName = function (className) {\n      var names = className.trim().replace(/\\s+/g, ' ').split(' ');\n      var HTMLCollection = [];\n      traverseDescendants([this], function (descendant) {\n        var descendantClassName = descendant.attribs.class;\n        if (descendantClassName && names.every(function (name) {\n          return descendantClassName.indexOf(name) > -1;\n        })) {\n          HTMLCollection.push(descendant);\n        }\n      });\n      return HTMLCollection;\n    };\n  }\n\n  if (!ElementPrototype.querySelectorAll) {\n    // https://docs.webplatform.org/wiki/css/selectors_api/querySelectorAll\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll\n    ElementPrototype.querySelectorAll = function (selectors) {\n      var _this = this;\n\n      selectors = selectors.replace(/(>)(\\S)/g, '$1 $2').trim(); // add space for '>' selector\n\n      // using right to left execution => https://github.com/fb55/css-select#how-does-it-work\n      var instructions = getInstructions(selectors);\n      var discover = instructions.shift();\n\n      var total = instructions.length;\n      return discover(this).filter(function (node) {\n        var step = 0;\n        while (step < total) {\n          node = instructions[step](node, _this);\n          if (!node) {\n            // hierarchy doesn't match\n            return false;\n          }\n          step += 1;\n        }\n        return true;\n      });\n    };\n  }\n\n  if (!ElementPrototype.contains) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\n    ElementPrototype.contains = function (element) {\n      var inclusive = false;\n      traverseDescendants([this], function (descendant, done) {\n        if (descendant === element) {\n          inclusive = true;\n          done();\n        }\n      });\n      return inclusive;\n    };\n  }\n\n  return true;\n}\n\n/**\n * Retrieve transformation steps\n *\n * @param  {Array.<string>}   selectors - [description]\n * @return {Array.<Function>}           - [description]\n */\nfunction getInstructions(selectors) {\n  return selectors.split(' ').reverse().map(function (selector, step) {\n    var discover = step === 0;\n\n    var _selector$split = selector.split(':'),\n        _selector$split2 = _slicedToArray(_selector$split, 2),\n        type = _selector$split2[0],\n        pseudo = _selector$split2[1];\n\n    var validate = null;\n    var instruction = null;\n\n    switch (true) {\n\n      // child: '>'\n      case />/.test(type):\n        instruction = function checkParent(node) {\n          return function (validate) {\n            return validate(node.parent) && node.parent;\n          };\n        };\n        break;\n\n      // class: '.'\n      case /^\\./.test(type):\n        {\n          var names = type.substr(1).split('.');\n          validate = function validate(node) {\n            var nodeClassName = node.attribs.class;\n            return nodeClassName && names.every(function (name) {\n              return nodeClassName.indexOf(name) > -1;\n            });\n          };\n          instruction = function checkClass(node, root) {\n            if (discover) {\n              return node.getElementsByClassName(names.join(' '));\n            }\n            return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n          };\n          break;\n        }\n\n      // attribute: '[key=\"value\"]'\n      case /^\\[/.test(type):\n        {\n          var _type$replace$split = type.replace(/\\[|\\]|\"/g, '').split('='),\n              _type$replace$split2 = _slicedToArray(_type$replace$split, 2),\n              attributeKey = _type$replace$split2[0],\n              attributeValue = _type$replace$split2[1];\n\n          validate = function validate(node) {\n            var hasAttribute = Object.keys(node.attribs).indexOf(attributeKey) > -1;\n            if (hasAttribute) {\n              // regard optional attributeValue\n              if (!attributeValue || node.attribs[attributeKey] === attributeValue) {\n                return true;\n              }\n            }\n            return false;\n          };\n          instruction = function checkAttribute(node, root) {\n            if (discover) {\n              var NodeList = [];\n              traverseDescendants([node], function (descendant) {\n                if (validate(descendant)) {\n                  NodeList.push(descendant);\n                }\n              });\n              return NodeList;\n            }\n            return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n          };\n          break;\n        }\n\n      // id: '#'\n      case /^#/.test(type):\n        {\n          var id = type.substr(1);\n          validate = function validate(node) {\n            return node.attribs.id === id;\n          };\n          instruction = function checkId(node, root) {\n            if (discover) {\n              var NodeList = [];\n              traverseDescendants([node], function (descendant, done) {\n                if (validate(descendant)) {\n                  NodeList.push(descendant);\n                  done();\n                }\n              });\n              return NodeList;\n            }\n            return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n          };\n          break;\n        }\n\n      // universal: '*'\n      case /\\*/.test(type):\n        {\n          validate = function validate() {\n            return true;\n          };\n          instruction = function checkUniversal(node, root) {\n            if (discover) {\n              var NodeList = [];\n              traverseDescendants([node], function (descendant) {\n                return NodeList.push(descendant);\n              });\n              return NodeList;\n            }\n            return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n          };\n          break;\n        }\n\n      // tag: '...'\n      default:\n        validate = function validate(node) {\n          return node.name === type;\n        };\n        instruction = function checkTag(node, root) {\n          if (discover) {\n            var NodeList = [];\n            traverseDescendants([node], function (descendant) {\n              if (validate(descendant)) {\n                NodeList.push(descendant);\n              }\n            });\n            return NodeList;\n          }\n          return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n        };\n    }\n\n    if (!pseudo) {\n      return instruction;\n    }\n\n    var rule = pseudo.match(/-(child|type)\\((\\d+)\\)$/);\n    var kind = rule[1];\n    var index = parseInt(rule[2], 10) - 1;\n\n    var validatePseudo = function validatePseudo(node) {\n      if (node) {\n        var compareSet = node.parent.childTags;\n        if (kind === 'type') {\n          compareSet = compareSet.filter(validate);\n        }\n        var nodeIndex = compareSet.findIndex(function (child) {\n          return child === node;\n        });\n        if (nodeIndex === index) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    return function enhanceInstruction(node) {\n      var match = instruction(node);\n      if (discover) {\n        return match.reduce(function (NodeList, matchedNode) {\n          if (validatePseudo(matchedNode)) {\n            NodeList.push(matchedNode);\n          }\n          return NodeList;\n        }, []);\n      }\n      return validatePseudo(match) && match;\n    };\n  });\n}\n\n/**\n * Walking recursive to invoke callbacks\n *\n * @param {Array.<HTMLElement>} nodes   - [description]\n * @param {Function}            handler - [description]\n */\nfunction traverseDescendants(nodes, handler) {\n  nodes.forEach(function (node) {\n    var progress = true;\n    handler(node, function () {\n      return progress = false;\n    });\n    if (node.childTags && progress) {\n      traverseDescendants(node.childTags, handler);\n    }\n  });\n}\n\n/**\n * Bubble up from bottom to top\n *\n * @param  {HTMLELement} node     - [description]\n * @param  {HTMLELement} root     - [description]\n * @param  {Function}    validate - [description]\n * @return {HTMLELement}          - [description]\n */\nfunction getAncestor(node, root, validate) {\n  while (node.parent) {\n    node = node.parent;\n    if (validate(node)) {\n      return node;\n    }\n    if (node === root) {\n      break;\n    }\n  }\n  return null;\n}\nmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * # Select\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * Construct a unique CSS query selector to access the selected DOM element(s).\n                                                                                                                                                                                                                                                                               * For longevity it applies different matching and optimization strategies.\n                                                                                                                                                                                                                                                                               */\n\n\nexports.getSingleSelector = getSingleSelector;\nexports.getMultiSelector = getMultiSelector;\nexports.default = getQuerySelector;\n\nvar _css2xpath = __webpack_require__(5);\n\nvar _css2xpath2 = _interopRequireDefault(_css2xpath);\n\nvar _adapt = __webpack_require__(3);\n\nvar _adapt2 = _interopRequireDefault(_adapt);\n\nvar _match = __webpack_require__(7);\n\nvar _match2 = _interopRequireDefault(_match);\n\nvar _optimize = __webpack_require__(2);\n\nvar _optimize2 = _interopRequireDefault(_optimize);\n\nvar _utilities = __webpack_require__(1);\n\nvar _common = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Get a selector for the provided element\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      options - [description]\n * @return {string}              - [description]\n */\nfunction getSingleSelector(element) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n  if (element.nodeType === 3) {\n    element = element.parentNode;\n  }\n\n  if (element.nodeType !== 1) {\n    throw new Error('Invalid input - only HTMLElements or representations of them are supported! (not \"' + (typeof element === 'undefined' ? 'undefined' : _typeof(element)) + '\")');\n  }\n\n  var globalModified = (0, _adapt2.default)(element, options);\n\n  var selector = (0, _match2.default)(element, options);\n  var optimized = (0, _optimize2.default)(selector, element, options);\n\n  // debug\n  // console.log(`\n  //   selector:  ${selector}\n  //   optimized: ${optimized}\n  // `)\n\n  if (globalModified) {\n    delete true;\n  }\n\n  return optimized;\n}\n\n/**\n * Get a selector to match multiple descendants from an ancestor\n *\n * @param  {Array.<HTMLElement>|NodeList} elements - [description]\n * @param  {Object}                       options  - [description]\n * @return {string}                                - [description]\n */\nfunction getMultiSelector(elements) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n  if (!Array.isArray(elements)) {\n    elements = (0, _utilities.convertNodeList)(elements);\n  }\n\n  if (elements.some(function (element) {\n    return element.nodeType !== 1;\n  })) {\n    throw new Error('Invalid input - only an Array of HTMLElements or representations of them is supported!');\n  }\n\n  var globalModified = (0, _adapt2.default)(elements[0], options);\n  var select = (0, _common.getSelect)(options);\n\n  var ancestor = (0, _common.getCommonAncestor)(elements, options);\n  var ancestorSelector = getSingleSelector(ancestor, options);\n\n  // TODO: consider usage of multiple selectors + parent-child relation + check for part redundancy\n  var commonSelectors = getCommonSelectors(elements);\n  var descendantSelector = commonSelectors[0];\n\n  var selector = (0, _optimize2.default)(ancestorSelector + ' ' + descendantSelector, elements, options);\n  var selectorMatches = (0, _utilities.convertNodeList)(select(selector));\n\n  if (!elements.every(function (element) {\n    return selectorMatches.some(function (entry) {\n      return entry === element;\n    });\n  })) {\n    // TODO: cluster matches to split into similar groups for sub selections\n    return console.warn('\\n      The selected elements can\\'t be efficiently mapped.\\n      Its probably best to use multiple single selectors instead!\\n    ', elements);\n  }\n\n  if (globalModified) {\n    delete true;\n  }\n\n  return selector;\n}\n\n/**\n * Get selectors to describe a set of elements\n *\n * @param  {Array.<HTMLElements>} elements - [description]\n * @return {string}                        - [description]\n */\nfunction getCommonSelectors(elements) {\n  var _getCommonProperties = (0, _common.getCommonProperties)(elements),\n      classes = _getCommonProperties.classes,\n      attributes = _getCommonProperties.attributes,\n      tag = _getCommonProperties.tag;\n\n  var selectorPath = [];\n\n  if (tag) {\n    selectorPath.push(tag);\n  }\n\n  if (classes) {\n    var classSelector = classes.map(function (name) {\n      return '.' + name;\n    }).join('');\n    selectorPath.push(classSelector);\n  }\n\n  if (attributes) {\n    var attributeSelector = Object.keys(attributes).reduce(function (parts, name) {\n      parts.push('[' + name + '=\"' + attributes[name] + '\"]');\n      return parts;\n    }, []).join('');\n    selectorPath.push(attributeSelector);\n  }\n\n  if (selectorPath.length) {\n    // TODO: check for parent-child relation\n  }\n\n  return [selectorPath.join('')];\n}\n\n/**\n * Choose action depending on the input (multiple/single)\n *\n * NOTE: extended detection is used for special cases like the <select> element with <options>\n *\n * @param  {HTMLElement|NodeList|Array.<HTMLElement>} input   - [description]\n * @param  {Object}                                   options - [description]\n * @return {string}                                           - [description]\n */\nfunction getQuerySelector(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (input.length && !input.name) {\n    return getMultiSelector(input, options);\n  }\n  var result = getSingleSelector(input, options);\n  if (options && [1, 'xpath'].includes(options.format)) {\n    return (0, _css2xpath2.default)(result);\n  }\n\n  return result;\n}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n(function () {\n  var xpath_to_lower = function xpath_to_lower(s) {\n    return 'translate(' + (s || 'normalize-space()') + ', \\'ABCDEFGHJIKLMNOPQRSTUVWXYZ\\'' + ', \\'abcdefghjiklmnopqrstuvwxyz\\')';\n  },\n      xpath_ends_with = function xpath_ends_with(s1, s2) {\n    return 'substring(' + s1 + ',' + 'string-length(' + s1 + ')-string-length(' + s2 + ')+1)=' + s2;\n  },\n      xpath_url = function xpath_url(s) {\n    return 'substring-before(concat(substring-after(' + (s || xpath_url_attrs) + ',\"://\"),\"?\"),\"?\")';\n  },\n      xpath_url_path = function xpath_url_path(s) {\n    return 'substring-after(' + (s || xpath_url_attrs) + ',\"/\")';\n  },\n      xpath_url_domain = function xpath_url_domain(s) {\n    return 'substring-before(concat(substring-after(' + (s || xpath_url_attrs) + ',\"://\"),\"/\"),\"/\")';\n  },\n      xpath_url_attrs = '@href|@src',\n      xpath_lower_case = xpath_to_lower(),\n      xpath_ns_uri = 'ancestor-or-self::*[last()]/@url',\n      xpath_ns_path = xpath_url_path(xpath_url(xpath_ns_uri)),\n      xpath_has_protocal = '(starts-with(' + xpath_url_attrs + ',\"http://\") or starts-with(' + xpath_url_attrs + ',\"https://\"))',\n      xpath_is_internal = 'starts-with(' + xpath_url() + ',' + xpath_url_domain(xpath_ns_uri) + ') or ' + xpath_ends_with(xpath_url_domain(), xpath_url_domain(xpath_ns_uri)),\n      xpath_is_local = '(' + xpath_has_protocal + ' and starts-with(' + xpath_url() + ',' + xpath_url(xpath_ns_uri) + '))',\n      xpath_is_path = 'starts-with(' + xpath_url_attrs + ',\"/\")',\n      xpath_is_local_path = 'starts-with(' + xpath_url_path() + ',' + xpath_ns_path + ')',\n      xpath_normalize_space = 'normalize-space()',\n      xpath_internal = '[not(' + xpath_has_protocal + ') or ' + xpath_is_internal + ']',\n      xpath_external = '[' + xpath_has_protocal + ' and not(' + xpath_is_internal + ')]',\n      escape_literal = String.fromCharCode(30),\n      escape_parens = String.fromCharCode(31),\n      regex_string_literal = /(\"[^\"\\x1E]*\"|'[^'\\x1E]*'|=\\s*[^\\s\\]\\'\\\"]+)/g,\n      regex_escaped_literal = /['\"]?(\\x1E+)['\"]?/g,\n      regex_css_wrap_pseudo = /(\\x1F\\)|[^\\)])\\:(first|limit|last|gt|lt|eq|nth)([^\\-]|$)/,\n      regex_specal_chars = /[\\x1C-\\x1F]+/g,\n      regex_first_axis = /^([\\s\\(\\x1F]*)(\\.?[^\\.\\/\\(]{1,2}[a-z]*:*)/,\n      regex_filter_prefix = /(^|\\/|\\:)\\[/g,\n      regex_attr_prefix = /([^\\(\\[\\/\\|\\s\\x1F])\\@/g,\n      regex_nth_equation = /^([-0-9]*)n.*?([0-9]*)$/,\n      css_combinators_regex = /\\s*(!?[+>~,^ ])\\s*(\\.?\\/+|[a-z\\-]+::)?([a-z\\-]+\\()?((and\\s*|or\\s*|mod\\s*)?[^+>~,\\s'\"\\]\\|\\^\\$\\!\\<\\=\\x1C-\\x1F]+)?/g,\n      css_combinators_callback = function css_combinators_callback(match, operator, axis, func, literal, exclude, offset, orig) {\n    var prefix = ''; // If we can, we'll prefix a '.'\n\n    // XPath operators can look like node-name selectors\n    // Detect false positive for \" and\", \" or\", \" mod\"\n    if (operator === ' ' && exclude !== undefined) {\n      return match;\n    }\n\n    if (axis === undefined) {\n      // Only allow node-selecting XPath functions\n      // Detect false positive for \" + count(...)\", \" count(...)\", \" > position()\", etc.\n      if (func !== undefined && func !== 'node(' && func !== 'text(' && func !== 'comment(') {\n        return;\n      } else if (literal === undefined) {\n        literal = func;\n      } // Handle case \" + text()\", \" > comment()\", etc. where \"func\" is our \"literal\"\n\n      // XPath math operators match some CSS combinators\n      // Detect false positive for \" + 1\", \" > 1\", etc.\n      if (isNumeric(literal)) {\n        return match;\n      }\n\n      var prevChar = orig.charAt(offset - 1);\n\n      if (prevChar.length === 0 || prevChar === '(' || prevChar === '|' || prevChar === ':') {\n        prefix = '.';\n      }\n    }\n\n    // Return if we don't have a selector to follow the axis\n    if (literal === undefined) {\n      if (offset + match.length === orig.length) {\n        literal = '*';\n      } else {\n        return match;\n      }\n    }\n\n    switch (operator) {\n      case ' ':\n        return '//' + literal;\n      case '>':\n        return '/' + literal;\n      case '+':\n        return prefix + '/following-sibling::*[1]/self::' + literal;\n      case '~':\n        return prefix + '/following-sibling::' + literal;\n      case ',':\n        if (axis === undefined) {}\n        axis = './/';\n        return '|' + axis + literal;\n      case '^':\n        // first child\n        return '/child::*[1]/self::' + literal;\n      case '!^':\n        // last child\n        return '/child::*[last()]/self::' + literal;\n      case '! ':\n        // ancestor-or-self\n        return '/ancestor-or-self::' + literal;\n      case '!>':\n        // direct parent\n        return '/parent::' + literal;\n      case '!+':\n        // adjacent preceding sibling\n        return '/preceding-sibling::*[1]/self::' + literal;\n      case '!~':\n        // preceding sibling\n        return '/preceding-sibling::' + literal;\n      // case '~~'\n      // return '/following-sibling::*/self::|'+selectorStart(orig, offset)+'/preceding-sibling::*/self::'+literal;\n    }\n  },\n      css_attributes_regex = /\\[([^\\@\\|\\*\\=\\^\\~\\$\\!\\(\\/\\s\\x1C-\\x1F]+)\\s*(([\\|\\*\\~\\^\\$\\!]?)=?\\s*(\\x1E+))?\\]/g,\n      css_attributes_callback = function css_attributes_callback(str, attr, comp, op, val, offset, orig) {\n    var axis = '';\n    var prevChar = orig.charAt(offset - 1);\n\n    /*\n    if (prevChar === '/' || // found after an axis shortcut (\"/\", \"//\", etc.)\n        prevChar === ':')   // found after an axis (\"self::\", \"parent::\", etc.)\n        axis = '*';*/\n\n    switch (op) {\n      case '!':\n        return axis + '[not(@' + attr + ') or @' + attr + '!=\"' + val + '\"]';\n      case '$':\n        return axis + '[substring(@' + attr + ',string-length(@' + attr + ')-(string-length(\"' + val + '\")-1))=\"' + val + '\"]';\n      case '^':\n        return axis + '[starts-with(@' + attr + ',\"' + val + '\")]';\n      case '~':\n        return axis + '[contains(concat(\" \",normalize-space(@' + attr + '),\" \"),concat(\" \",\"' + val + '\",\" \"))]';\n      case '*':\n        return axis + '[contains(@' + attr + ',\"' + val + '\")]';\n      case '|':\n        return axis + '[@' + attr + '=\"' + val + '\" or starts-with(@' + attr + ',concat(\"' + val + '\",\"-\"))]';\n      default:\n        if (comp === undefined) {\n          if (attr.charAt(attr.length - 1) === '(' || attr.search(/^[0-9]+$/) !== -1 || attr.indexOf(':') !== -1) {\n            return str;\n          }\n          return axis + '[@' + attr + ']';\n        } else {\n          return axis + '[@' + attr + '=\"' + val + '\"]';\n        }\n    }\n  },\n      css_pseudo_classes_regex = /:([a-z\\-]+)(\\((\\x1F+)(([^\\x1F]+(\\3\\x1F+)?)*)(\\3\\)))?/g,\n      css_pseudo_classes_callback = function css_pseudo_classes_callback(match, name, g1, g2, arg, g3, g4, g5, offset, orig) {\n    if (orig.charAt(offset - 1) === ':' && orig.charAt(offset - 2) !== ':') {\n      // XPath \"axis::node-name\" will match\n      // Detect false positive \":node-name\"\n      return match;\n    }\n\n    if (name === 'odd' || name === 'even') {\n      arg = name;\n      name = 'nth-of-type';\n    }\n\n    switch (name) {// name.toLowerCase()?\n      case 'after':\n        return '[count(' + css2xpath('preceding::' + arg, true) + ') > 0]';\n      case 'after-sibling':\n        return '[count(' + css2xpath('preceding-sibling::' + arg, true) + ') > 0]';\n      case 'before':\n        return '[count(' + css2xpath('following::' + arg, true) + ') > 0]';\n      case 'before-sibling':\n        return '[count(' + css2xpath('following-sibling::' + arg, true) + ') > 0]';\n      case 'checked':\n        return '[@selected or @checked]';\n      case 'contains':\n        return '[contains(' + xpath_normalize_space + ',' + arg + ')]';\n      case 'icontains':\n        return '[contains(' + xpath_lower_case + ',' + xpath_to_lower(arg) + ')]';\n      case 'empty':\n        return '[not(*) and not(normalize-space())]';\n      case 'enabled':\n      case 'disabled':\n        return '[@' + name + ']';\n      case 'first-child':\n        return '[not(preceding-sibling::*)]';\n      case 'first':\n      case 'limit':\n      case 'first-of-type':\n        if (arg !== undefined) {\n          return '[position()<=' + arg + ']';\n        }\n        return '[1]';\n      case 'gt':\n        // Position starts at 0 for consistency with Sizzle selectors\n        return '[position()>' + (parseInt(arg, 10) + 1) + ']';\n      case 'lt':\n        // Position starts at 0 for consistency with Sizzle selectors\n        return '[position()<' + (parseInt(arg, 10) + 1) + ']';\n      case 'last-child':\n        return '[not(following-sibling::*)]';\n      case 'only-child':\n        return '[not(preceding-sibling::*) and not(following-sibling::*)]';\n      case 'only-of-type':\n        return '[not(preceding-sibling::*[name()=name(self::node())]) and not(following-sibling::*[name()=name(self::node())])]';\n      case 'nth-child':\n        if (isNumeric(arg)) {\n          return '[(count(preceding-sibling::*)+1) = ' + arg + ']';\n        }\n        switch (arg) {\n          case 'even':\n            return '[(count(preceding-sibling::*)+1) mod 2=0]';\n          case 'odd':\n            return '[(count(preceding-sibling::*)+1) mod 2=1]';\n          default:\n            var a = (arg || '0').replace(regex_nth_equation, '$1+$2').split('+');\n\n            a[0] = a[0] || '1';\n            a[1] = a[1] || '0';\n            return '[(count(preceding-sibling::*)+1)>=' + a[1] + ' and ((count(preceding-sibling::*)+1)-' + a[1] + ') mod ' + a[0] + '=0]';\n        }\n      case 'nth-of-type':\n        if (isNumeric(arg)) {\n          return '[' + arg + ']';\n        }\n        switch (arg) {\n          case 'odd':\n            return '[position() mod 2=1]';\n          case 'even':\n            return '[position() mod 2=0 and position()>=0]';\n          default:\n            var a = (arg || '0').replace(regex_nth_equation, '$1+$2').split('+');\n\n            a[0] = a[0] || '1';\n            a[1] = a[1] || '0';\n            return '[position()>=' + a[1] + ' and (position()-' + a[1] + ') mod ' + a[0] + '=0]';\n        }\n      case 'eq':\n      case 'nth':\n        // Position starts at 0 for consistency with Sizzle selectors\n        if (isNumeric(arg)) {\n          return '[' + (parseInt(arg, 10) + 1) + ']';\n        }\n\n        return '[1]';\n      case 'text':\n        return '[@type=\"text\"]';\n      case 'istarts-with':\n        return '[starts-with(' + xpath_lower_case + ',' + xpath_to_lower(arg) + ')]';\n      case 'starts-with':\n        return '[starts-with(' + xpath_normalize_space + ',' + arg + ')]';\n      case 'iends-with':\n        return '[' + xpath_ends_with(xpath_lower_case, xpath_to_lower(arg)) + ']';\n      case 'ends-with':\n        return '[' + xpath_ends_with(xpath_normalize_space, arg) + ']';\n      case 'has':\n        var xpath = prependAxis(css2xpath(arg, true), './/');\n\n        return '[count(' + xpath + ') > 0]';\n      case 'has-sibling':\n        var xpath = css2xpath('preceding-sibling::' + arg, true);\n\n        return '[count(' + xpath + ') > 0 or count(following-sibling::' + xpath.substr(19) + ') > 0]';\n      case 'has-parent':\n        return '[count(' + css2xpath('parent::' + arg, true) + ') > 0]';\n      case 'has-ancestor':\n        return '[count(' + css2xpath('ancestor::' + arg, true) + ') > 0]';\n      case 'last':\n      case 'last-of-type':\n        if (arg !== undefined) {\n          return '[position()>last()-' + arg + ']';\n        }\n        return '[last()]';\n      case 'selected':\n        // Sizzle: \"(option) elements that are currently selected\"\n        return '[local-name()=\"option\" and @selected]';\n      case 'skip':\n      case 'skip-first':\n        return '[position()>' + arg + ']';\n      case 'skip-last':\n        if (arg !== undefined) {\n          return '[last()-position()>=' + arg + ']';\n        }\n        return '[position()<last()]';\n      case 'root':\n        return '/ancestor::[last()]';\n      case 'range':\n        var arr = arg.split(',');\n\n        return '[' + arr[0] + '<=position() and position()<=' + arr[1] + ']';\n      case 'input':\n        // Sizzle: \"input, button, select, and textarea are all considered to be input elements.\"\n        return '[local-name()=\"input\" or local-name()=\"button\" or local-name()=\"select\" or local-name()=\"textarea\"]';\n      case 'internal':\n        return xpath_internal;\n      case 'external':\n        return xpath_external;\n      case 'http':\n      case 'https':\n      case 'mailto':\n      case 'javascript':\n        return '[starts-with(@href,concat(\"' + name + '\",\":\"))]';\n      case 'domain':\n        return '[(string-length(' + xpath_url_domain() + ')=0 and contains(' + xpath_url_domain(xpath_ns_uri) + ',' + arg + ')) or contains(' + xpath_url_domain() + ',' + arg + ')]';\n      case 'path':\n        return '[starts-with(' + xpath_url_path() + ',substring-after(\"' + arg + '\",\"/\"))]';\n      case 'not':\n        var xpath = css2xpath(arg, true);\n\n        if (xpath.charAt(0) === '[') {\n          xpath = 'self::node()' + xpath;\n        }\n        return '[not(' + xpath + ')]';\n      case 'target':\n        return '[starts-with(@href, \"#\")]';\n      case 'root':\n        return 'ancestor-or-self::*[last()]';\n      /* case 'active':\n      case 'focus':\n      case 'hover':\n      case 'link':\n      case 'visited':\n          return '';*/\n      case 'lang':\n        return '[@lang=\"' + arg + '\"]';\n      case 'read-only':\n      case 'read-write':\n        return '[@' + name.replace('-', '') + ']';\n      case 'valid':\n      case 'required':\n      case 'in-range':\n      case 'out-of-range':\n        return '[@' + name + ']';\n      default:\n        return match;\n    }\n  },\n      css_ids_classes_regex = /(#|\\.)([^\\#\\@\\.\\/\\(\\[\\)\\]\\|\\:\\s\\+\\>\\<\\'\\\"\\x1D-\\x1F]+)/g,\n      css_ids_classes_callback = function css_ids_classes_callback(str, op, val, offset, orig) {\n    var axis = '';\n    /* var prevChar = orig.charAt(offset-1);\n    if (prevChar.length === 0 ||\n        prevChar === '/' ||\n        prevChar === '(')\n        axis = '*';\n    else if (prevChar === ':')\n        axis = 'node()';*/\n    if (op === '#') {\n      return axis + '[@id=\"' + val + '\"]';\n    }\n    return axis + '[contains(concat(\" \",normalize-space(@class),\" \"),\" ' + val + ' \")]';\n  };\n\n  // Prepend descendant-or-self if no other axis is specified\n  function prependAxis(s, axis) {\n    return s.replace(regex_first_axis, function (match, start, literal) {\n      if (literal.substr(literal.length - 2) === '::') // Already has axis::\n        {\n          return match;\n        }\n\n      if (literal.charAt(0) === '[') {\n        axis += '*';\n      }\n      // else if (axis.charAt(axis.length-1) === ')')\n      //    axis += '/';\n      return start + axis + literal;\n    });\n  }\n\n  // Find the begining of the selector, starting at i and working backwards\n  function selectorStart(s, i) {\n    var depth = 0;\n    var offset = 0;\n\n    while (i--) {\n      switch (s.charAt(i)) {\n        case ' ':\n        case escape_parens:\n          offset++;\n          break;\n        case '[':\n        case '(':\n          depth--;\n\n          if (depth < 0) {\n            return ++i + offset;\n          }\n          break;\n        case ']':\n        case ')':\n          depth++;\n          break;\n        case ',':\n        case '|':\n          if (depth === 0) {\n            return ++i + offset;\n          }\n        default:\n          offset = 0;\n      }\n    }\n\n    return 0;\n  }\n\n  // Check if string is numeric\n  function isNumeric(s) {\n    var num = parseInt(s, 10);\n\n    return !isNaN(num) && '' + num === s;\n  }\n\n  // Append escape \"char\" to \"open\" or \"close\"\n  function escapeChar(s, open, close, char) {\n    var depth = 0;\n\n    return s.replace(new RegExp('[\\\\' + open + '\\\\' + close + ']', 'g'), function (a) {\n      if (a === open) {\n        depth++;\n      }\n\n      if (a === open) {\n        return a + repeat(char, depth);\n      } else {\n        return repeat(char, depth--) + a;\n      }\n    });\n  }\n\n  function repeat(str, num) {\n    num = Number(num);\n    var result = '';\n\n    while (true) {\n      if (num & 1) {\n        result += str;\n      }\n      num >>>= 1;\n\n      if (num <= 0) {\n        break;\n      }\n      str += str;\n    }\n\n    return result;\n  }\n\n  function convertEscaping(value) {\n    return value && value.replace(/\\\\([`\\\\/:\\?&!#$%^()[\\]{|}*+;,.<=>@~])/g, '$1').replace(/\\\\(['\"])/g, '$1$1').replace(/\\\\A /g, '\\n');\n  }\n\n  function css2xpath(s, nested) {\n    // s = s.trim();\n\n    if (nested === true) {\n      // Replace :pseudo-classes\n      s = s.replace(css_pseudo_classes_regex, css_pseudo_classes_callback);\n\n      // Replace #ids and .classes\n      s = s.replace(css_ids_classes_regex, css_ids_classes_callback);\n\n      return s;\n    }\n\n    // Tag open and close parenthesis pairs (for RegExp searches)\n    s = escapeChar(s, '(', ')', escape_parens);\n\n    // Remove and save any string literals\n    var literals = [];\n\n    s = s.replace(regex_string_literal, function (s, a) {\n      if (a.charAt(0) === '=') {\n        a = a.substr(1).trim();\n\n        if (isNumeric(a)) {\n          return s;\n        }\n      } else {\n        a = a.substr(1, a.length - 2);\n      }\n\n      return repeat(escape_literal, literals.push(convertEscaping(a)));\n    });\n\n    // Replace CSS combinators (\" \", \"+\", \">\", \"~\", \",\") and reverse combinators (\"!\", \"!+\", \"!>\", \"!~\")\n    s = s.replace(css_combinators_regex, css_combinators_callback);\n\n    // Replace CSS attribute filters\n    s = s.replace(css_attributes_regex, css_attributes_callback);\n\n    // Wrap certain :pseudo-classes in parens (to collect node-sets)\n    while (true) {\n      var index = s.search(regex_css_wrap_pseudo);\n\n      if (index === -1) {\n        break;\n      }\n      index = s.indexOf(':', index);\n      var start = selectorStart(s, index);\n\n      s = s.substr(0, start) + '(' + s.substring(start, index) + ')' + s.substr(index);\n    }\n\n    // Replace :pseudo-classes\n    s = s.replace(css_pseudo_classes_regex, css_pseudo_classes_callback);\n\n    // Replace #ids and .classes\n    s = s.replace(css_ids_classes_regex, css_ids_classes_callback);\n\n    // Restore the saved string literals\n    s = s.replace(regex_escaped_literal, function (s, a) {\n      var str = literals[a.length - 1];\n\n      return '\"' + str + '\"';\n    });\n\n    // Remove any special characters\n    s = s.replace(regex_specal_chars, '');\n\n    // add * to stand-alone filters\n    s = s.replace(regex_filter_prefix, '$1*[');\n\n    // add \"/\" between @attribute selectors\n    s = s.replace(regex_attr_prefix, '$1/@');\n\n    /*\n    Combine multiple filters?\n     s = escapeChar(s, '[', ']', filter_char);\n    s = s.replace(/(\\x1D+)\\]\\[\\1(.+?[^\\x1D])\\1\\]/g, ' and ($2)$1]')\n    */\n\n    s = prependAxis(s, './/'); // prepend \".//\" axis to begining of CSS selector\n    return s;\n  }\n\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = css2xpath;\n  } else {\n    window.css2xpath = css2xpath;\n  }\n})();\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n/*!\n * Sizzle CSS Selector Engine v2.3.6\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2021-02-16\n */\n(function (window) {\n\tvar i,\n\t    support,\n\t    Expr,\n\t    getText,\n\t    isXML,\n\t    tokenize,\n\t    compile,\n\t    select,\n\t    outermostContext,\n\t    sortInput,\n\t    hasDuplicate,\n\n\n\t// Local document vars\n\tsetDocument,\n\t    document,\n\t    docElem,\n\t    documentIsHTML,\n\t    rbuggyQSA,\n\t    rbuggyMatches,\n\t    matches,\n\t    contains,\n\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\t    preferredDoc = window.document,\n\t    dirruns = 0,\n\t    done = 0,\n\t    classCache = createCache(),\n\t    tokenCache = createCache(),\n\t    compilerCache = createCache(),\n\t    nonnativeSelectorCache = createCache(),\n\t    sortOrder = function sortOrder(a, b) {\n\t\tif (a === b) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\n\t// Instance methods\n\thasOwn = {}.hasOwnProperty,\n\t    arr = [],\n\t    pop = arr.pop,\n\t    pushNative = arr.push,\n\t    push = arr.push,\n\t    slice = arr.slice,\n\n\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function indexOf(list, elem) {\n\t\tvar i = 0,\n\t\t    len = list.length;\n\t\tfor (; i < len; i++) {\n\t\t\tif (list[i] === elem) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\t    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" + \"ismap|loop|multiple|open|readonly|required|scoped\",\n\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t// Operator (capture 2)\n\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t// \"Attribute values must be CSS identifiers [capture 5]\n\t// or strings [capture 3 or capture 4]\"\n\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n\t    pseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t// 2. simple (capture 6)\n\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t// 3. anything else (capture 2)\n\t\".*\" + \")\\\\)|)\",\n\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n\t    rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n\t    rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n\t    rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n\t    rdescend = new RegExp(whitespace + \"|>\"),\n\t    rpseudo = new RegExp(pseudos),\n\t    ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n\t    matchExpr = {\n\t\t\"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n\t\t\"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n\t\t\"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n\t\t\"ATTR\": new RegExp(\"^\" + attributes),\n\t\t\"PSEUDO\": new RegExp(\"^\" + pseudos),\n\t\t\"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n\t\t\"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n\t},\n\t    rhtml = /HTML$/i,\n\t    rinputs = /^(?:input|select|textarea|button)$/i,\n\t    rheader = /^h\\d$/i,\n\t    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t    rsibling = /[+~]/,\n\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"),\n\t    funescape = function funescape(escape, nonHex) {\n\t\tvar high = \"0x\" + escape.slice(1) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\tnonHex :\n\n\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t// Support: IE <=11+\n\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t// surrogate pair\n\t\thigh < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n\t},\n\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t    fcssescape = function fcssescape(ch, asCodePoint) {\n\t\tif (asCodePoint) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif (ch === \"\\0\") {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function unloadHandler() {\n\t\tsetDocument();\n\t},\n\t    inDisabledFieldset = addCombinator(function (elem) {\n\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t}, { dir: \"parentNode\", next: \"legend\" });\n\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\t// eslint-disable-next-line no-unused-expressions\n\t\tarr[preferredDoc.childNodes.length].nodeType;\n\t} catch (e) {\n\t\tpush = { apply: arr.length ?\n\n\t\t\t// Leverage slice if possible\n\t\t\tfunction (target, els) {\n\t\t\t\tpushNative.apply(target, slice.call(els));\n\t\t\t} :\n\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction (target, els) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t    i = 0;\n\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile (target[j++] = els[i++]) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction Sizzle(selector, context, results, seed) {\n\t\tvar m,\n\t\t    i,\n\t\t    elem,\n\t\t    nid,\n\t\t    match,\n\t\t    groups,\n\t\t    newSelector,\n\t\t    newContext = context && context.ownerDocument,\n\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\t\tresults = results || [];\n\n\t\t// Return early from calls with invalid selector or context\n\t\tif (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\n\t\t\treturn results;\n\t\t}\n\n\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\tif (!seed) {\n\t\t\tsetDocument(context);\n\t\t\tcontext = context || document;\n\n\t\t\tif (documentIsHTML) {\n\n\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\tif (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n\n\t\t\t\t\t// ID selector\n\t\t\t\t\tif (m = match[1]) {\n\n\t\t\t\t\t\t// Document context\n\t\t\t\t\t\tif (nodeType === 9) {\n\t\t\t\t\t\t\tif (elem = context.getElementById(m)) {\n\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif (elem.id === m) {\n\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Type selector\n\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByTagName(selector));\n\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t// Class selector\n\t\t\t\t\t} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n\n\t\t\t\t\t\tpush.apply(results, context.getElementsByClassName(m));\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\tif (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\tnodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n\n\t\t\t\t\tnewSelector = selector;\n\t\t\t\t\tnewContext = context;\n\n\t\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\t\tif (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {\n\n\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\tnewContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\n\t\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\t\tif (newContext !== context || !support.scope) {\n\n\t\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\t\tif (nid = context.getAttribute(\"id\")) {\n\t\t\t\t\t\t\t\tnid = nid.replace(rcssescape, fcssescape);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontext.setAttribute(\"id\", nid = expando);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\tgroups = tokenize(selector);\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tgroups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply(results, newContext.querySelectorAll(newSelector));\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch (qsaError) {\n\t\t\t\t\t\tnonnativeSelectorCache(selector, true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (nid === expando) {\n\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All others\n\t\treturn select(selector.replace(rtrim, \"$1\"), context, results, seed);\n\t}\n\n\t/**\n  * Create key-value caches of limited size\n  * @returns {function(string, object)} Returns the Object data after storing it on itself with\n  *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n  *\tdeleting the oldest entry\n  */\n\tfunction createCache() {\n\t\tvar keys = [];\n\n\t\tfunction cache(key, value) {\n\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif (keys.push(key + \" \") > Expr.cacheLength) {\n\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[keys.shift()];\n\t\t\t}\n\t\t\treturn cache[key + \" \"] = value;\n\t\t}\n\t\treturn cache;\n\t}\n\n\t/**\n  * Mark a function for special use by Sizzle\n  * @param {Function} fn The function to mark\n  */\n\tfunction markFunction(fn) {\n\t\tfn[expando] = true;\n\t\treturn fn;\n\t}\n\n\t/**\n  * Support testing using an element\n  * @param {Function} fn Passed the created element and returns a boolean result\n  */\n\tfunction assert(fn) {\n\t\tvar el = document.createElement(\"fieldset\");\n\n\t\ttry {\n\t\t\treturn !!fn(el);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\n\t\t\t// Remove from its parent by default\n\t\t\tif (el.parentNode) {\n\t\t\t\tel.parentNode.removeChild(el);\n\t\t\t}\n\n\t\t\t// release memory in IE\n\t\t\tel = null;\n\t\t}\n\t}\n\n\t/**\n  * Adds the same handler for all of the specified attrs\n  * @param {String} attrs Pipe-separated list of attributes\n  * @param {Function} handler The method that will be applied\n  */\n\tfunction addHandle(attrs, handler) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t    i = arr.length;\n\n\t\twhile (i--) {\n\t\t\tExpr.attrHandle[arr[i]] = handler;\n\t\t}\n\t}\n\n\t/**\n  * Checks document order of two siblings\n  * @param {Element} a\n  * @param {Element} b\n  * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n  */\n\tfunction siblingCheck(a, b) {\n\t\tvar cur = b && a,\n\t\t    diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;\n\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif (diff) {\n\t\t\treturn diff;\n\t\t}\n\n\t\t// Check if b follows a\n\t\tif (cur) {\n\t\t\twhile (cur = cur.nextSibling) {\n\t\t\t\tif (cur === b) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a ? 1 : -1;\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for input types\n  * @param {String} type\n  */\n\tfunction createInputPseudo(type) {\n\t\treturn function (elem) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for buttons\n  * @param {String} type\n  */\n\tfunction createButtonPseudo(type) {\n\t\treturn function (elem) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for :enabled/:disabled\n  * @param {Boolean} disabled true for :disabled; false for :enabled\n  */\n\tfunction createDisabledPseudo(disabled) {\n\n\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\treturn function (elem) {\n\n\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\tif (\"form\" in elem) {\n\n\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t// All such elements have a \"form\" property.\n\t\t\t\tif (elem.parentNode && elem.disabled === false) {\n\n\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\tif (\"label\" in elem) {\n\t\t\t\t\t\tif (\"label\" in elem.parentNode) {\n\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n\t\t\t\t}\n\n\t\t\t\treturn elem.disabled === disabled;\n\n\t\t\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t} else if (\"label\" in elem) {\n\t\t\t\treturn elem.disabled === disabled;\n\t\t\t}\n\n\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\treturn false;\n\t\t};\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for positionals\n  * @param {Function} fn\n  */\n\tfunction createPositionalPseudo(fn) {\n\t\treturn markFunction(function (argument) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function (seed, matches) {\n\t\t\t\tvar j,\n\t\t\t\t    matchIndexes = fn([], seed.length, argument),\n\t\t\t\t    i = matchIndexes.length;\n\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (seed[j = matchIndexes[i]]) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n  * Checks a node for validity as a Sizzle context\n  * @param {Element|Object=} context\n  * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n  */\n\tfunction testContext(context) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\n\t/**\n  * Detects XML nodes\n  * @param {Element|Object} elem An element or a document\n  * @returns {Boolean} True iff elem is a non-HTML XML node\n  */\n\tisXML = Sizzle.isXML = function (elem) {\n\t\tvar namespace = elem && elem.namespaceURI,\n\t\t    docElem = elem && (elem.ownerDocument || elem).documentElement;\n\n\t\t// Support: IE <=8\n\t\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t\t// https://bugs.jquery.com/ticket/4833\n\t\treturn !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n\t};\n\n\t/**\n  * Sets document-related variables once based on the current document\n  * @param {Element|Object} [doc] An element or document object to use to set the document\n  * @returns {Object} Returns the current document\n  */\n\tsetDocument = Sizzle.setDocument = function (node) {\n\t\tvar hasCompare,\n\t\t    subWindow,\n\t\t    doc = node ? node.ownerDocument || node : preferredDoc;\n\n\t\t// Return early if doc is invalid or already selected\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n\t\t\treturn document;\n\t\t}\n\n\t\t// Update global variables\n\t\tdocument = doc;\n\t\tdocElem = document.documentElement;\n\t\tdocumentIsHTML = !isXML(document);\n\n\t\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n\n\t\t\t// Support: IE 11, Edge\n\t\t\tif (subWindow.addEventListener) {\n\t\t\t\tsubWindow.addEventListener(\"unload\", unloadHandler, false);\n\n\t\t\t\t// Support: IE 9 - 10 only\n\t\t\t} else if (subWindow.attachEvent) {\n\t\t\t\tsubWindow.attachEvent(\"onunload\", unloadHandler);\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n\t\t// Support: Safari 6.0 only\n\t\t// Safari 6.0 supports :scope but it's an alias of :root there.\n\t\tsupport.scope = assert(function (el) {\n\t\t\tdocElem.appendChild(el).appendChild(document.createElement(\"div\"));\n\t\t\treturn typeof el.querySelectorAll !== \"undefined\" && !el.querySelectorAll(\":scope fieldset div\").length;\n\t\t});\n\n\t\t/* Attributes\n  ---------------------------------------------------------------------- */\n\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function (el) {\n\t\t\tel.className = \"i\";\n\t\t\treturn !el.getAttribute(\"className\");\n\t\t});\n\n\t\t/* getElement(s)By*\n  ---------------------------------------------------------------------- */\n\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function (el) {\n\t\t\tel.appendChild(document.createComment(\"\"));\n\t\t\treturn !el.getElementsByTagName(\"*\").length;\n\t\t});\n\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test(document.getElementsByClassName);\n\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programmatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function (el) {\n\t\t\tdocElem.appendChild(el).id = expando;\n\t\t\treturn !document.getElementsByName || !document.getElementsByName(expando).length;\n\t\t});\n\n\t\t// ID filter and find\n\t\tif (support.getById) {\n\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\tvar elem = context.getElementById(id);\n\t\t\t\t\treturn elem ? [elem] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// Support: IE 6 - 7 only\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\tvar node,\n\t\t\t\t\t    i,\n\t\t\t\t\t    elems,\n\t\t\t\t\t    elem = context.getElementById(id);\n\n\t\t\t\t\tif (elem) {\n\n\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\telems = context.getElementsByName(id);\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (elem = elems[i++]) {\n\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n\t\t\tif (typeof context.getElementsByTagName !== \"undefined\") {\n\t\t\t\treturn context.getElementsByTagName(tag);\n\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if (support.qsa) {\n\t\t\t\treturn context.querySelectorAll(tag);\n\t\t\t}\n\t\t} : function (tag, context) {\n\t\t\tvar elem,\n\t\t\t    tmp = [],\n\t\t\t    i = 0,\n\n\n\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\tresults = context.getElementsByTagName(tag);\n\n\t\t\t// Filter out possible comments\n\t\t\tif (tag === \"*\") {\n\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\ttmp.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n\t\t\tif (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n\t\t\t\treturn context.getElementsByClassName(className);\n\t\t\t}\n\t\t};\n\n\t\t/* QSA/matchesSelector\n  ---------------------------------------------------------------------- */\n\n\t\t// QSA and matchesSelector support\n\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See https://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\n\t\tif (support.qsa = rnative.test(document.querySelectorAll)) {\n\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function (el) {\n\n\t\t\t\tvar input;\n\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\";\n\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n\t\t\t\t\trbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t}\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif (!el.querySelectorAll(\"[selected]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\tif (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t\t// around the issue.\n\t\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\t\t\tinput = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute(\"name\", \"\");\n\t\t\t\tel.appendChild(input);\n\t\t\t\tif (!el.querySelectorAll(\"[name='']\").length) {\n\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t}\n\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif (!el.querySelectorAll(\":checked\").length) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\tif (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n\t\t\t\tel.querySelectorAll(\"\\\\\\f\");\n\t\t\t\trbuggyQSA.push(\"[\\\\r\\\\n\\\\f]\");\n\t\t\t});\n\n\t\t\tassert(function (el) {\n\t\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\";\n\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute(\"type\", \"hidden\");\n\t\t\t\tel.appendChild(input).setAttribute(\"name\", \"D\");\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif (el.querySelectorAll(\"[name=d]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n\t\t\t\t}\n\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif (el.querySelectorAll(\":enabled\").length !== 2) {\n\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t}\n\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\tdocElem.appendChild(el).disabled = true;\n\t\t\t\tif (el.querySelectorAll(\":disabled\").length !== 2) {\n\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Opera 10 - 11 only\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\n\t\tif (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\n\t\t\tassert(function (el) {\n\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call(el, \"*\");\n\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call(el, \"[s!='']:x\");\n\t\t\t\trbuggyMatches.push(\"!=\", pseudos);\n\t\t\t});\n\t\t}\n\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n\n\t\t/* Contains\n  ---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test(docElem.compareDocumentPosition);\n\n\t\t// Element contains another\n\t\t// Purposefully self-exclusive\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t    bup = b && b.parentNode;\n\t\t\treturn a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n\t\t} : function (a, b) {\n\t\t\tif (b) {\n\t\t\t\twhile (b = b.parentNode) {\n\t\t\t\t\tif (b === a) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t/* Sorting\n  ---------------------------------------------------------------------- */\n\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ? function (a, b) {\n\n\t\t\t// Flag for duplicate removal\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif (compare) {\n\t\t\t\treturn compare;\n\t\t\t}\n\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tcompare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t\t// Disconnected nodes\n\t\t\tif (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\tif (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\tif (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} : function (a, b) {\n\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar cur,\n\t\t\t    i = 0,\n\t\t\t    aup = a.parentNode,\n\t\t\t    bup = b.parentNode,\n\t\t\t    ap = [a],\n\t\t\t    bp = [b];\n\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif (!aup || !bup) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t/* eslint-disable eqeqeq */\n\t\t\t\treturn a == document ? -1 : b == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\n\t\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if (aup === bup) {\n\t\t\t\treturn siblingCheck(a, b);\n\t\t\t}\n\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\tap.unshift(cur);\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\tbp.unshift(cur);\n\t\t\t}\n\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile (ap[i] === bp[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck(ap[i], bp[i]) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t\t};\n\n\t\treturn document;\n\t};\n\n\tSizzle.matches = function (expr, elements) {\n\t\treturn Sizzle(expr, null, null, elements);\n\t};\n\n\tSizzle.matchesSelector = function (elem, expr) {\n\t\tsetDocument(elem);\n\n\t\tif (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call(elem, expr);\n\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif (ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tnonnativeSelectorCache(expr, true);\n\t\t\t}\n\t\t}\n\n\t\treturn Sizzle(expr, document, null, [elem]).length > 0;\n\t};\n\n\tSizzle.contains = function (context, elem) {\n\n\t\t// Set document vars if needed\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif ((context.ownerDocument || context) != document) {\n\t\t\tsetDocument(context);\n\t\t}\n\t\treturn contains(context, elem);\n\t};\n\n\tSizzle.attr = function (elem, name) {\n\n\t\t// Set document vars if needed\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif ((elem.ownerDocument || elem) != document) {\n\t\t\tsetDocument(elem);\n\t\t}\n\n\t\tvar fn = Expr.attrHandle[name.toLowerCase()],\n\n\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\n\t\treturn val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t};\n\n\tSizzle.escape = function (sel) {\n\t\treturn (sel + \"\").replace(rcssescape, fcssescape);\n\t};\n\n\tSizzle.error = function (msg) {\n\t\tthrow new Error(\"Syntax error, unrecognized expression: \" + msg);\n\t};\n\n\t/**\n  * Document sorting and removing duplicates\n  * @param {ArrayLike} results\n  */\n\tSizzle.uniqueSort = function (results) {\n\t\tvar elem,\n\t\t    duplicates = [],\n\t\t    j = 0,\n\t\t    i = 0;\n\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice(0);\n\t\tresults.sort(sortOrder);\n\n\t\tif (hasDuplicate) {\n\t\t\twhile (elem = results[i++]) {\n\t\t\t\tif (elem === results[i]) {\n\t\t\t\t\tj = duplicates.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j--) {\n\t\t\t\tresults.splice(duplicates[j], 1);\n\t\t\t}\n\t\t}\n\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\n\t\treturn results;\n\t};\n\n\t/**\n  * Utility function for retrieving the text value of an array of DOM nodes\n  * @param {Array|Element} elem\n  */\n\tgetText = Sizzle.getText = function (elem) {\n\t\tvar node,\n\t\t    ret = \"\",\n\t\t    i = 0,\n\t\t    nodeType = elem.nodeType;\n\n\t\tif (!nodeType) {\n\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile (node = elem[i++]) {\n\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText(node);\n\t\t\t}\n\t\t} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif (typeof elem.textContent === \"string\") {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\n\t\t\t\t// Traverse its children\n\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\tret += getText(elem);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nodeType === 3 || nodeType === 4) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\n\t\t// Do not include comment or processing instruction nodes\n\n\t\treturn ret;\n\t};\n\n\tExpr = Sizzle.selectors = {\n\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\n\t\tcreatePseudo: markFunction,\n\n\t\tmatch: matchExpr,\n\n\t\tattrHandle: {},\n\n\t\tfind: {},\n\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function ATTR(match) {\n\t\t\t\tmatch[1] = match[1].replace(runescape, funescape);\n\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n\t\t\t\tif (match[2] === \"~=\") {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\n\t\t\t\treturn match.slice(0, 4);\n\t\t\t},\n\n\t\t\t\"CHILD\": function CHILD(match) {\n\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n    \t1 type (only|nth|...)\n    \t2 what (child|of-type)\n    \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n    \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n    \t5 sign of xn-component\n    \t6 x of xn-component\n    \t7 sign of y-component\n    \t8 y of y-component\n    */\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\tif (match[1].slice(0, 3) === \"nth\") {\n\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif (!match[3]) {\n\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n\t\t\t\t\tmatch[5] = +(match[7] + match[8] || match[3] === \"odd\");\n\n\t\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if (match[3]) {\n\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t}\n\n\t\t\t\treturn match;\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function PSEUDO(match) {\n\t\t\t\tvar excess,\n\t\t\t\t    unquoted = !match[6] && match[2];\n\n\t\t\t\tif (matchExpr[\"CHILD\"].test(match[0])) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if (unquoted && rpseudo.test(unquoted) && (\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\texcess = tokenize(unquoted, true)) && (\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\texcess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice(0, excess);\n\t\t\t\t\tmatch[2] = unquoted.slice(0, excess);\n\t\t\t\t}\n\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice(0, 3);\n\t\t\t}\n\t\t},\n\n\t\tfilter: {\n\n\t\t\t\"TAG\": function TAG(nodeNameSelector) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ? function () {\n\t\t\t\t\treturn true;\n\t\t\t\t} : function (elem) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CLASS\": function CLASS(className) {\n\t\t\t\tvar pattern = classCache[className + \" \"];\n\n\t\t\t\treturn pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n\t\t\t\t\treturn pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t\"ATTR\": function ATTR(name, operator, check) {\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar result = Sizzle.attr(elem, name);\n\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif (!operator) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult += \"\";\n\n\t\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\t\treturn operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n\t\t\t\t\t/* eslint-enable max-len */\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CHILD\": function CHILD(type, what, _argument, first, last) {\n\t\t\t\tvar simple = type.slice(0, 3) !== \"nth\",\n\t\t\t\t    forward = type.slice(-4) !== \"last\",\n\t\t\t\t    ofType = what === \"of-type\";\n\n\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction (elem) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} : function (elem, _context, xml) {\n\t\t\t\t\tvar cache,\n\t\t\t\t\t    uniqueCache,\n\t\t\t\t\t    outerCache,\n\t\t\t\t\t    node,\n\t\t\t\t\t    nodeIndex,\n\t\t\t\t\t    start,\n\t\t\t\t\t    dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t    parent = elem.parentNode,\n\t\t\t\t\t    name = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t    useCache = !xml && !ofType,\n\t\t\t\t\t    diff = false;\n\n\t\t\t\t\tif (parent) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif (simple) {\n\t\t\t\t\t\t\twhile (dir) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile (node = node[dir]) {\n\t\t\t\t\t\t\t\t\tif (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [forward ? parent.firstChild : parent.lastChild];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif (forward && useCache) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[nodeIndex];\n\n\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (\n\n\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\tdiff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif (node.nodeType === 1 && ++diff && node === elem) {\n\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, nodeIndex, diff];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif (useCache) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif (diff === false) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\tif ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, diff];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (node === elem) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || diff % first === 0 && diff / first >= 0;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function PSEUDO(pseudo, argument) {\n\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo);\n\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif (fn[expando]) {\n\t\t\t\t\treturn fn(argument);\n\t\t\t\t}\n\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif (fn.length > 1) {\n\t\t\t\t\targs = [pseudo, pseudo, \"\", argument];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t    matched = fn(seed, argument),\n\t\t\t\t\t\t    i = matched.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tidx = indexOf(seed, matched[i]);\n\t\t\t\t\t\t\tseed[idx] = !(matches[idx] = matched[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (elem) {\n\t\t\t\t\t\treturn fn(elem, 0, args);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\n\t\tpseudos: {\n\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function (selector) {\n\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t    results = [],\n\t\t\t\t    matcher = compile(selector.replace(rtrim, \"$1\"));\n\n\t\t\t\treturn matcher[expando] ? markFunction(function (seed, matches, _context, xml) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t    unmatched = matcher(seed, null, xml, []),\n\t\t\t\t\t    i = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) : function (elem, _context, xml) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher(input, null, xml, results);\n\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"has\": markFunction(function (selector) {\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn Sizzle(selector, elem).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"contains\": markFunction(function (text) {\n\t\t\t\ttext = text.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn (elem.textContent || getText(elem)).indexOf(text) > -1;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction(function (lang) {\n\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif (!ridentifier.test(lang || \"\")) {\n\t\t\t\t\tSizzle.error(\"unsupported lang: \" + lang);\n\t\t\t\t}\n\t\t\t\tlang = lang.replace(runescape, funescape).toLowerCase();\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ((elem = elem.parentNode) && elem.nodeType === 1);\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function target(elem) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice(1) === elem.id;\n\t\t\t},\n\n\t\t\t\"root\": function root(elem) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\n\t\t\t\"focus\": function focus(elem) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": createDisabledPseudo(false),\n\t\t\t\"disabled\": createDisabledPseudo(true),\n\n\t\t\t\"checked\": function checked(elem) {\n\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n\t\t\t},\n\n\t\t\t\"selected\": function selected(elem) {\n\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\n\t\t\t// Contents\n\t\t\t\"empty\": function empty(elem) {\n\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\tif (elem.nodeType < 6) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t\"parent\": function parent(elem) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"](elem);\n\t\t\t},\n\n\t\t\t// Element/input types\n\t\t\t\"header\": function header(elem) {\n\t\t\t\treturn rheader.test(elem.nodeName);\n\t\t\t},\n\n\t\t\t\"input\": function input(elem) {\n\t\t\t\treturn rinputs.test(elem.nodeName);\n\t\t\t},\n\n\t\t\t\"button\": function button(elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\n\t\t\t\"text\": function text(elem) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && (\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t(attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n\t\t\t},\n\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function () {\n\t\t\t\treturn [0];\n\t\t\t}),\n\n\t\t\t\"last\": createPositionalPseudo(function (_matchIndexes, length) {\n\t\t\t\treturn [length - 1];\n\t\t\t}),\n\n\t\t\t\"eq\": createPositionalPseudo(function (_matchIndexes, length, argument) {\n\t\t\t\treturn [argument < 0 ? argument + length : argument];\n\t\t\t}),\n\n\t\t\t\"even\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"odd\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument > length ? length : argument;\n\t\t\t\tfor (; --i >= 0;) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor (; ++i < length;) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n\t// Add button/input type pseudos\n\tfor (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n\t\tExpr.pseudos[i] = createInputPseudo(i);\n\t}\n\tfor (i in { submit: true, reset: true }) {\n\t\tExpr.pseudos[i] = createButtonPseudo(i);\n\t}\n\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\n\ttokenize = Sizzle.tokenize = function (selector, parseOnly) {\n\t\tvar matched,\n\t\t    match,\n\t\t    tokens,\n\t\t    type,\n\t\t    soFar,\n\t\t    groups,\n\t\t    preFilters,\n\t\t    cached = tokenCache[selector + \" \"];\n\n\t\tif (cached) {\n\t\t\treturn parseOnly ? 0 : cached.slice(0);\n\t\t}\n\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\n\t\twhile (soFar) {\n\n\t\t\t// Comma and first run\n\t\t\tif (!matched || (match = rcomma.exec(soFar))) {\n\t\t\t\tif (match) {\n\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice(match[0].length) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push(tokens = []);\n\t\t\t}\n\n\t\t\tmatched = false;\n\n\t\t\t// Combinators\n\t\t\tif (match = rcombinators.exec(soFar)) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace(rtrim, \" \")\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t}\n\n\t\t\t// Filters\n\t\t\tfor (type in Expr.filter) {\n\t\t\t\tif ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!matched) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n\n\t\t// Cache the tokens\n\t\ttokenCache(selector, groups).slice(0);\n\t};\n\n\tfunction toSelector(tokens) {\n\t\tvar i = 0,\n\t\t    len = tokens.length,\n\t\t    selector = \"\";\n\t\tfor (; i < len; i++) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\n\tfunction addCombinator(matcher, combinator, base) {\n\t\tvar dir = combinator.dir,\n\t\t    skip = combinator.next,\n\t\t    key = skip || dir,\n\t\t    checkNonElements = base && key === \"parentNode\",\n\t\t    doneName = done++;\n\n\t\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction (elem, context, xml) {\n\t\t\twhile (elem = elem[dir]) {\n\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\treturn matcher(elem, context, xml);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction (elem, context, xml) {\n\t\t\tvar oldCache,\n\t\t\t    uniqueCache,\n\t\t\t    outerCache,\n\t\t\t    newCache = [dirruns, doneName];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif (xml) {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\touterCache = elem[expando] || (elem[expando] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n\t\t\t\t\t\tif (skip && skip === elem.nodeName.toLowerCase()) {\n\t\t\t\t\t\t\telem = elem[dir] || elem;\n\t\t\t\t\t\t} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn newCache[2] = oldCache[2];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[key] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif (newCache[2] = matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\n\tfunction elementMatcher(matchers) {\n\t\treturn matchers.length > 1 ? function (elem, context, xml) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (!matchers[i](elem, context, xml)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} : matchers[0];\n\t}\n\n\tfunction multipleContexts(selector, contexts, results) {\n\t\tvar i = 0,\n\t\t    len = contexts.length;\n\t\tfor (; i < len; i++) {\n\t\t\tSizzle(selector, contexts[i], results);\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction condense(unmatched, map, filter, context, xml) {\n\t\tvar elem,\n\t\t    newUnmatched = [],\n\t\t    i = 0,\n\t\t    len = unmatched.length,\n\t\t    mapped = map != null;\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (elem = unmatched[i]) {\n\t\t\t\tif (!filter || filter(elem, context, xml)) {\n\t\t\t\t\tnewUnmatched.push(elem);\n\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\tmap.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newUnmatched;\n\t}\n\n\tfunction setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n\t\tif (postFilter && !postFilter[expando]) {\n\t\t\tpostFilter = setMatcher(postFilter);\n\t\t}\n\t\tif (postFinder && !postFinder[expando]) {\n\t\t\tpostFinder = setMatcher(postFinder, postSelector);\n\t\t}\n\t\treturn markFunction(function (seed, results, context, xml) {\n\t\t\tvar temp,\n\t\t\t    i,\n\t\t\t    elem,\n\t\t\t    preMap = [],\n\t\t\t    postMap = [],\n\t\t\t    preexisting = results.length,\n\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n\t\t\t    matcherOut = matcher ?\n\n\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\tpostFinder || (seed ? preFilter : preexisting || postFilter) ?\n\n\t\t\t// ...intermediate processing is necessary\n\t\t\t[] :\n\n\t\t\t// ...otherwise use results directly\n\t\t\tresults : matcherIn;\n\n\t\t\t// Find primary matches\n\t\t\tif (matcher) {\n\t\t\t\tmatcher(matcherIn, matcherOut, context, xml);\n\t\t\t}\n\n\t\t\t// Apply postFilter\n\t\t\tif (postFilter) {\n\t\t\t\ttemp = condense(matcherOut, postMap);\n\t\t\t\tpostFilter(temp, [], context, xml);\n\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (elem = temp[i]) {\n\t\t\t\t\t\tmatcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (seed) {\n\t\t\t\tif (postFinder || preFilter) {\n\t\t\t\t\tif (postFinder) {\n\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (elem = matcherOut[i]) {\n\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push(matcherIn[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder(null, matcherOut = [], temp, xml);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\t\t\t\tif (postFinder) {\n\t\t\t\t\tpostFinder(null, results, matcherOut, xml);\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply(results, matcherOut);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction matcherFromTokens(tokens) {\n\t\tvar checkContext,\n\t\t    matcher,\n\t\t    j,\n\t\t    len = tokens.length,\n\t\t    leadingRelative = Expr.relative[tokens[0].type],\n\t\t    implicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t    i = leadingRelative ? 1 : 0,\n\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator(function (elem) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true),\n\t\t    matchAnyContext = addCombinator(function (elem) {\n\t\t\treturn indexOf(checkContext, elem) > -1;\n\t\t}, implicitRelative, true),\n\t\t    matchers = [function (elem, context, xml) {\n\t\t\tvar ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t}];\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (matcher = Expr.relative[tokens[i].type]) {\n\t\t\t\tmatchers = [addCombinator(elementMatcher(matchers), matcher)];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif (matcher[expando]) {\n\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor (; j < len; j++) {\n\t\t\t\t\t\tif (Expr.relative[tokens[j].type]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n\t\t\t\t}\n\t\t\t\tmatchers.push(matcher);\n\t\t\t}\n\t\t}\n\n\t\treturn elementMatcher(matchers);\n\t}\n\n\tfunction matcherFromGroupMatchers(elementMatchers, setMatchers) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t    byElement = elementMatchers.length > 0,\n\t\t    superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n\t\t\tvar elem,\n\t\t\t    j,\n\t\t\t    matcher,\n\t\t\t    matchedCount = 0,\n\t\t\t    i = \"0\",\n\t\t\t    unmatched = seed && [],\n\t\t\t    setMatched = [],\n\t\t\t    contextBackup = outermostContext,\n\n\n\t\t\t// We must always have either seed elements or outermost context\n\t\t\telems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n\n\n\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\tdirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n\t\t\t    len = elems.length;\n\n\t\t\tif (outermost) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor (; i !== len && (elem = elems[i]) != null; i++) {\n\t\t\t\tif (byElement && elem) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif (!context && elem.ownerDocument != document) {\n\t\t\t\t\t\tsetDocument(elem);\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile (matcher = elementMatchers[j++]) {\n\t\t\t\t\t\tif (matcher(elem, context || document, xml)) {\n\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (outermost) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif (bySet) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif (elem = !matcher && elem) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif (seed) {\n\t\t\t\t\t\tunmatched.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif (bySet && i !== matchedCount) {\n\t\t\t\tj = 0;\n\t\t\t\twhile (matcher = setMatchers[j++]) {\n\t\t\t\t\tmatcher(unmatched, setMatched, context, xml);\n\t\t\t\t}\n\n\t\t\t\tif (seed) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif (matchedCount > 0) {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (!(unmatched[i] || setMatched[i])) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call(results);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense(setMatched);\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply(results, setMatched);\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\n\t\t\t\t\tSizzle.uniqueSort(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif (outermost) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\t\treturn bySet ? markFunction(superMatcher) : superMatcher;\n\t}\n\n\tcompile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n\t\tvar i,\n\t\t    setMatchers = [],\n\t\t    elementMatchers = [],\n\t\t    cached = compilerCache[selector + \" \"];\n\n\t\tif (!cached) {\n\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif (!match) {\n\t\t\t\tmatch = tokenize(selector);\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile (i--) {\n\t\t\t\tcached = matcherFromTokens(match[i]);\n\t\t\t\tif (cached[expando]) {\n\t\t\t\t\tsetMatchers.push(cached);\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push(cached);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\n\t/**\n  * A low-level selection function that works with Sizzle's compiled\n  *  selector functions\n  * @param {String|Function} selector A selector or a pre-compiled\n  *  selector function built with Sizzle.compile\n  * @param {Element} context\n  * @param {Array} [results]\n  * @param {Array} [seed] A set of elements to match against\n  */\n\tselect = Sizzle.select = function (selector, context, results, seed) {\n\t\tvar i,\n\t\t    tokens,\n\t\t    token,\n\t\t    type,\n\t\t    find,\n\t\t    compiled = typeof selector === \"function\" && selector,\n\t\t    match = !seed && tokenize(selector = compiled.selector || selector);\n\n\t\tresults = results || [];\n\n\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t// (the latter of which guarantees us context)\n\t\tif (match.length === 1) {\n\n\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\ttokens = match[0] = match[0].slice(0);\n\t\t\tif (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\n\t\t\t\tcontext = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\t\t\t\tif (!context) {\n\t\t\t\t\treturn results;\n\n\t\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if (compiled) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\n\t\t\t\tselector = selector.slice(tokens.shift().value.length);\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\t\t\twhile (i--) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif (Expr.relative[type = token.type]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (find = Expr.find[type]) {\n\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice(i, 1);\n\t\t\t\t\t\tselector = seed.length && toSelector(tokens);\n\t\t\t\t\t\tif (!selector) {\n\t\t\t\t\t\t\tpush.apply(results, seed);\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n\t\treturn results;\n\t};\n\n\t// One-time assignments\n\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t// Initialize against the default document\n\tsetDocument();\n\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function (el) {\n\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n\t});\n\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif (!assert(function (el) {\n\t\tel.innerHTML = \"<a href='#'></a>\";\n\t\treturn el.firstChild.getAttribute(\"href\") === \"#\";\n\t})) {\n\t\taddHandle(\"type|href|height|width\", function (elem, name, isXML) {\n\t\t\tif (!isXML) {\n\t\t\t\treturn elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif (!support.attributes || !assert(function (el) {\n\t\tel.innerHTML = \"<input/>\";\n\t\tel.firstChild.setAttribute(\"value\", \"\");\n\t\treturn el.firstChild.getAttribute(\"value\") === \"\";\n\t})) {\n\t\taddHandle(\"value\", function (elem, _name, isXML) {\n\t\t\tif (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif (!assert(function (el) {\n\t\treturn el.getAttribute(\"disabled\") == null;\n\t})) {\n\t\taddHandle(booleans, function (elem, name, isXML) {\n\t\t\tvar val;\n\t\t\tif (!isXML) {\n\t\t\t\treturn elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t\t}\n\t\t});\n\t}\n\n\t// EXPOSE\n\tvar _sizzle = window.Sizzle;\n\n\tSizzle.noConflict = function () {\n\t\tif (window.Sizzle === Sizzle) {\n\t\t\twindow.Sizzle = _sizzle;\n\t\t}\n\n\t\treturn Sizzle;\n\t};\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\treturn Sizzle;\n\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\t\t// Sizzle requires that there be a global window in Common-JS like environments\n\t} else if (typeof module !== \"undefined\" && module.exports) {\n\t\tmodule.exports = Sizzle;\n\t} else {\n\t\twindow.Sizzle = Sizzle;\n\t}\n\n\t// EXPOSE\n})(window);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = match;\n\nvar _common = __webpack_require__(0);\n\nvar _utilities = __webpack_require__(1);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**\n                                                                                                                                                                                                     * # Match\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * Retrieve selector for a node.\n                                                                                                                                                                                                     */\n\nvar defaultIgnore = {\n  attribute: function attribute(attributeName) {\n    return ['style', 'data-reactid', 'data-react-checksum'].indexOf(attributeName) > -1;\n  }\n};\n\n/**\n * Get the path of the element\n *\n * @param  {HTMLElement} node    - [description]\n * @param  {Object}      options - [description]\n * @return {string}              - [description]\n */\nfunction match(node, options) {\n  var _options$root = options.root,\n      root = _options$root === undefined ? document : _options$root,\n      _options$skip = options.skip,\n      skip = _options$skip === undefined ? null : _options$skip,\n      _options$priority = options.priority,\n      priority = _options$priority === undefined ? ['id', 'class', 'href', 'src'] : _options$priority,\n      _options$ignore = options.ignore,\n      ignore = _options$ignore === undefined ? {} : _options$ignore,\n      format = options.format;\n\n\n  var path = [];\n  var element = node;\n  var length = path.length;\n  var jquery = format === 'jquery';\n  var select = (0, _common.getSelect)(options);\n\n  var skipCompare = skip && (Array.isArray(skip) ? skip : [skip]).map(function (entry) {\n    if (typeof entry !== 'function') {\n      return function (element) {\n        return element === entry;\n      };\n    }\n    return entry;\n  });\n\n  var skipChecks = function skipChecks(element) {\n    return skip && skipCompare.some(function (compare) {\n      return compare(element);\n    });\n  };\n\n  Object.keys(ignore).forEach(function (type) {\n    var predicate = ignore[type];\n    if (typeof predicate === 'function') return;\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString();\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp((0, _utilities.escapeValue)(predicate).replace(/\\\\/g, '\\\\\\\\'));\n    }\n    if (typeof predicate === 'boolean') {\n      predicate = predicate ? /(?:)/ : /.^/;\n    }\n    // check class-/attributename for regex\n    ignore[type] = function (name, value) {\n      return predicate.test(value);\n    };\n  });\n\n  while (element !== root && element.nodeType !== 11) {\n    if (skipChecks(element) !== true) {\n      // ~ global\n      if (checkAttributes(priority, element, ignore, path, select, root)) break;\n      if (checkTag(element, ignore, path, select, root)) break;\n\n      // ~ local\n      checkAttributes(priority, element, ignore, path, select);\n      if (path.length === length) {\n        checkTag(element, ignore, path, select);\n      }\n\n      if (jquery && path.length === length) {\n        checkContains(priority, element, ignore, path, select);\n      }\n\n      // define only one part each iteration\n      if (path.length === length) {\n        checkChilds(priority, element, ignore, path, select);\n      }\n    }\n\n    element = element.parentNode;\n    length = path.length;\n  }\n\n  if (element === root) {\n    var pattern = findPattern(priority, element, ignore, select);\n    path.unshift(pattern);\n  }\n\n  return path.join(' ');\n}\n\n/**\n * Extend path with attribute identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @param  {HTMLElement}    parent   - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkAttributes(priority, element, ignore, path, select) {\n  var parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : element.parentNode;\n\n  var pattern = findAttributesPattern(priority, element, ignore, select, parent);\n  if (pattern) {\n    var matches = select(pattern, parent);\n    if (matches.length === 1) {\n      path.unshift(pattern);\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get class selector\n *\n * @param  {Array.<string>} classes - [description]\n * @param  {function}       select  - [description]\n * @param  {HTMLElement}    parent  - [description]\n * @return {string?}                - [description]\n */\nfunction getClassSelector() {\n  var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var select = arguments[1];\n  var parent = arguments[2];\n\n  var result = [[]];\n\n  classes.forEach(function (c) {\n    result.forEach(function (r) {\n      result.push(r.concat('.' + c));\n    });\n  });\n\n  result.shift();\n\n  result = result.sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < result.length; i++) {\n    var r = result[i].join('');\n    var matches = select(r, parent);\n    if (matches.length === 1) {\n      return r;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Lookup attribute identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n\n * @return {string?}                 - [description]\n */\nfunction findAttributesPattern(priority, element, ignore, select) {\n  var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : element.parentNode;\n\n  var attributes = element.attributes;\n  var attributeNames = Object.keys(attributes).map(function (val) {\n    return attributes[val].name;\n  }).filter(function (a) {\n    return priority.indexOf(a) < 0;\n  });\n\n  var sortedKeys = [].concat(_toConsumableArray(priority), _toConsumableArray(attributeNames));\n\n  var tagName = element.tagName.toLowerCase();\n\n  for (var i = 0, l = sortedKeys.length; i < l; i++) {\n    var key = sortedKeys[i];\n    var attribute = attributes[key];\n    var attributeName = (0, _utilities.escapeValue)(attribute && attribute.name);\n    var attributeValue = (0, _utilities.escapeValue)(attribute && attribute.value);\n    var useNamedIgnore = attributeName !== 'class';\n\n    var currentIgnore = useNamedIgnore && ignore[attributeName] || ignore.attribute;\n    var currentDefaultIgnore = useNamedIgnore && defaultIgnore[attributeName] || defaultIgnore.attribute;\n    if (checkIgnore(currentIgnore, attributeName, attributeValue, currentDefaultIgnore)) {\n      continue;\n    }\n\n    var pattern = '[' + attributeName + '=\"' + attributeValue + '\"]';\n    if (!attributeValue.trim()) {\n      return null;\n    }\n\n    if (attributeName === 'id') {\n      pattern = '#' + attributeValue;\n    }\n\n    if (attributeName === 'class') {\n      var _ret = function () {\n        var classNames = attributeValue.trim().split(/\\s+/g);\n        var classIgnore = ignore.class || defaultIgnore.class;\n        if (classIgnore) {\n          classNames = classNames.filter(function (className) {\n            return !classIgnore(className);\n          });\n        }\n        if (classNames.length === 0) {\n          return 'continue';\n        }\n        pattern = getClassSelector(classNames, select, parent);\n\n        if (!pattern) {\n          return 'continue';\n        }\n      }();\n\n      if (_ret === 'continue') continue;\n    }\n\n    return tagName + pattern;\n  }\n  return null;\n}\n\n/**\n * Extend path with tag identifier\n *\n * @param  {HTMLElement}    element - [description]\n * @param  {Object}         ignore  - [description]\n * @param  {Array.<string>} path    - [description]\n * @param  {function}       select  - [description]\n * @param  {HTMLElement}    parent  - [description]\n * @return {boolean}                - [description]\n */\nfunction checkTag(element, ignore, path, select) {\n  var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : element.parentNode;\n\n  var pattern = findTagPattern(element, ignore);\n  if (pattern) {\n    var matches = [];\n    matches = select(pattern, parent);\n    if (matches.length === 1) {\n      path.unshift(pattern);\n      if (pattern === 'iframe') {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lookup tag identifier\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      ignore  - [description]\n * @return {boolean}             - [description]\n */\nfunction findTagPattern(element, ignore) {\n  var tagName = element.tagName.toLowerCase();\n  if (checkIgnore(ignore.tag, null, tagName)) {\n    return null;\n  }\n  return tagName;\n}\n\n/**\n * Extend path with specific child identifier\n *\n * NOTE: 'childTags' is a custom property to use as a view filter for tags using 'adapter.js'\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkChilds(priority, element, ignore, path, select) {\n  var parent = element.parentNode;\n  var children = parent.childTags || parent.children;\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    if (child === element) {\n      var childPattern = findPattern(priority, child, ignore, select);\n      if (!childPattern) {\n        return console.warn('\\n          Element couldn\\'t be matched through strict ignore pattern!\\n        ', child, ignore, childPattern);\n      }\n      var pattern = '> ' + childPattern + ':nth-child(' + (i + 1) + ')';\n      path.unshift(pattern);\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Extend path with contains\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkContains(priority, element, ignore, path, select) {\n  var elementPattern = findPattern(priority, element, ignore, select);\n  var text = element.textContent.trim();\n  if (text.length > 0 && text.indexOf('\\n') < 0) {\n    var parent = element.parentNode;\n    var children = parent.childTags || parent.children;\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      if (child !== element) {\n        if (child.textContent.indexOf(text) > 0) {\n          return false;\n        }\n      }\n    }\n    var pattern = elementPattern + ':contains(\"' + text + '\")';\n    path.unshift(pattern);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Lookup identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @return {string}                  - [description]\n */\nfunction findPattern(priority, element, ignore, select) {\n  var pattern = findAttributesPattern(priority, element, ignore, select);\n  if (!pattern) {\n    pattern = findTagPattern(element, ignore);\n  }\n  return pattern;\n}\n\n/**\n * Validate with custom and default functions\n *\n * @param  {Function} predicate        - [description]\n * @param  {string?}  name             - [description]\n * @param  {string}   value            - [description]\n * @param  {Function} defaultPredicate - [description]\n * @return {boolean}                   - [description]\n */\nfunction checkIgnore(predicate, name, value, defaultPredicate) {\n  if (!value) {\n    return true;\n  }\n  var check = predicate || defaultPredicate;\n  if (!check) {\n    return false;\n  }\n  return check(name, value, defaultPredicate);\n}\nmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.common = exports.optimize = exports.getMultiSelector = exports.getSingleSelector = exports.select = undefined;\n\nvar _select = __webpack_require__(4);\n\nObject.defineProperty(exports, 'select', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_select).default;\n  }\n});\nObject.defineProperty(exports, 'getSingleSelector', {\n  enumerable: true,\n  get: function get() {\n    return _select.getSingleSelector;\n  }\n});\nObject.defineProperty(exports, 'getMultiSelector', {\n  enumerable: true,\n  get: function get() {\n    return _select.getMultiSelector;\n  }\n});\n\nvar _optimize = __webpack_require__(2);\n\nObject.defineProperty(exports, 'optimize', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_optimize).default;\n  }\n});\n\nvar _common2 = __webpack_require__(0);\n\nvar _common = _interopRequireWildcard(_common2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.common = _common;\n\n/***/ }\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// optimal-select.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 31e8eb15010e94eb2118","/**\n * # Common\n *\n * Process collections for similarities.\n */\n\n\n/**\n * Query document using correct selector\n *\n * @param  {Object}               options - [description]\n * @return {(selector: string, parent: HTMLElement) => Array.<HTMLElements>} - [description]\n */\nexport function getSelect (options = {}) {\n  if (options.format === 'jquery') {\n    const Sizzle = require('sizzle')\n    return function (selector, parent = null) {\n      return Sizzle(selector, parent || document)\n    }\n  }\n  return function (selector, parent = null) {\n    return (parent || document).querySelectorAll(selector)\n  } \n}\n\n\n/**\n * Find the last common ancestor of elements\n *\n * @param  {Array.<HTMLElements>} elements - [description]\n * @return {HTMLElement}                   - [description]\n */\nexport function getCommonAncestor (elements, options = {}) {\n\n  const {\n    root = document\n  } = options\n\n  const ancestors = []\n\n  elements.forEach((element, index) => {\n    const parents = []\n    while (element !== root) {\n      element = element.parentNode\n      parents.unshift(element)\n    }\n    ancestors[index] = parents\n  })\n\n  ancestors.sort((curr, next) => curr.length - next.length)\n\n  const shallowAncestor = ancestors.shift()\n\n  var ancestor = null\n\n  for (var i = 0, l = shallowAncestor.length; i < l; i++) {\n    const parent = shallowAncestor[i]\n    const missing = ancestors.some((otherParents) => {\n      return !otherParents.some((otherParent) => otherParent === parent)\n    })\n\n    if (missing) {\n      // TODO: find similar sub-parents, not the top root, e.g. sharing a class selector\n      break\n    }\n\n    ancestor = parent\n  }\n\n  return ancestor\n}\n\n/**\n * Get a set of common properties of elements\n *\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Object}                       - [description]\n */\nexport function getCommonProperties (elements) {\n\n  const commonProperties = {\n    classes: [],\n    attributes: {},\n    tag: null\n  }\n\n  elements.forEach((element) => {\n\n    var {\n      classes: commonClasses,\n      attributes: commonAttributes,\n      tag: commonTag\n    } = commonProperties\n\n    // ~ classes\n    if (commonClasses !== undefined) {\n      var classes = element.getAttribute('class')\n      if (classes) {\n        classes = classes.trim().split(' ')\n        if (!commonClasses.length) {\n          commonProperties.classes = classes\n        } else {\n          commonClasses = commonClasses.filter((entry) => classes.some((name) => name === entry))\n          if (commonClasses.length) {\n            commonProperties.classes = commonClasses\n          } else {\n            delete commonProperties.classes\n          }\n        }\n      } else {\n        // TODO: restructure removal as 2x set / 2x delete, instead of modify always replacing with new collection\n        delete commonProperties.classes\n      }\n    }\n\n    // ~ attributes\n    if (commonAttributes !== undefined) {\n      const elementAttributes = element.attributes\n      const attributes = Object.keys(elementAttributes).reduce((attributes, key) => {\n        const attribute = elementAttributes[key]\n        const attributeName = attribute.name\n        // NOTE: workaround detection for non-standard phantomjs NamedNodeMap behaviour\n        // (issue: https://github.com/ariya/phantomjs/issues/14634)\n        if (attribute && attributeName !== 'class') {\n          attributes[attributeName] = attribute.value\n        }\n        return attributes\n      }, {})\n\n      const attributesNames = Object.keys(attributes)\n      const commonAttributesNames = Object.keys(commonAttributes)\n\n      if (attributesNames.length) {\n        if (!commonAttributesNames.length) {\n          commonProperties.attributes = attributes\n        } else {\n          commonAttributes = commonAttributesNames.reduce((nextCommonAttributes, name) => {\n            const value = commonAttributes[name]\n            if (value === attributes[name]) {\n              nextCommonAttributes[name] = value\n            }\n            return nextCommonAttributes\n          }, {})\n          if (Object.keys(commonAttributes).length) {\n            commonProperties.attributes = commonAttributes\n          } else {\n            delete commonProperties.attributes\n          }\n        }\n      } else {\n        delete commonProperties.attributes\n      }\n    }\n\n    // ~ tag\n    if (commonTag !== undefined) {\n      const tag = element.tagName.toLowerCase()\n      if (!commonTag) {\n        commonProperties.tag = tag\n      } else if (tag !== commonTag) {\n        delete commonProperties.tag\n      }\n    }\n  })\n\n  return commonProperties\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/common.js","/**\n * # Utilities\n *\n * Convenience helpers.\n */\n\n/**\n * Create an array with the DOM nodes of the list\n *\n * @param  {NodeList}             nodes - [description]\n * @return {Array.<HTMLElement>}        - [description]\n */\nexport function convertNodeList (nodes) {\n  const { length } = nodes\n  const arr = new Array(length)\n  for (var i = 0; i < length; i++) {\n    arr[i] = nodes[i]\n  }\n  return arr\n}\n\n/**\n * Escape special characters and line breaks as a simplified version of 'CSS.escape()'\n *\n * Description of valid characters: https://mathiasbynens.be/notes/css-escapes\n *\n * @param  {String?} value - [description]\n * @return {String}        - [description]\n */\nexport function escapeValue (value) {\n  return value && value.replace(/['\"`\\\\/:?&!#$%^()[\\]{|}*+;,.<=>@~]/g, '\\\\$&')\n    .replace(/\\n/g, '\\u00a0')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utilities.js","/**\n * # Optimize\n *\n * 1.) Improve efficiency through shorter selectors by removing redundancy\n * 2.) Improve robustness through selector transformation\n */\n\nimport adapt from './adapt'\nimport { getSelect } from './common'\nimport { convertNodeList } from './utilities'\n\n/**\n * Apply different optimization techniques\n *\n * @param  {string}                          selector - [description]\n * @param  {HTMLElement|Array.<HTMLElement>} element  - [description]\n * @param  {Object}                          options  - [description]\n * @return {string}                                   - [description]\n */\nexport default function optimize (selector, elements, options = {}) {\n\n  if (selector.startsWith('> ')) {\n    selector = selector.replace('> ', '')\n  }\n\n  // convert single entry and NodeList\n  if (!Array.isArray(elements)) {\n    elements = !elements.length ? [elements] : convertNodeList(elements)\n  }\n\n  if (!elements.length || elements.some((element) => element.nodeType !== 1)) {\n    throw new Error('Invalid input - to compare HTMLElements its necessary to provide a reference of the selected node(s)! (missing \"elements\")')\n  }\n\n  const globalModified = adapt(elements[0], options)\n  const select = getSelect(options)\n\n  // chunk parts outside of quotes (http://stackoverflow.com/a/25663729, https://stackoverflow.com/a/16261693)\n  // var path = selector.replace(/> /g, '>').split(/\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)\n  var path = selector.replace(/> /g, '>').match(/(?:[^\\s\"]+|\"[^\"]*\")+/g)\n\n  if (path.length < 2) {\n    return optimizePart('', selector, '', elements, select)\n  }\n\n  const shortened = [path.pop()]\n  while (path.length > 1)  {\n    const current = path.pop()\n    const prePart = path.join(' ')\n    const postPart = shortened.join(' ')\n\n    const pattern = `${prePart} ${postPart}`\n    const matches = select(pattern)\n    const hasSameResult = matches.length === elements.length && elements.every((element, i) => element === matches[i])\n    if (!hasSameResult) {\n      shortened.unshift(optimizePart(prePart, current, postPart, elements, select))\n    }\n  }\n  shortened.unshift(path[0])\n  path = shortened\n\n  // optimize start + end\n  path[0] = optimizePart('', path[0], path.slice(1).join(' '), elements, select)\n  path[path.length-1] = optimizePart(path.slice(0, -1).join(' '), path[path.length-1], '', elements, select)\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return path.join(' ').replace(/>/g, '> ').trim()\n}\n\n/**\n * Improve a chunk of the selector\n *\n * @param  {string}              prePart  - [description]\n * @param  {string}              current  - [description]\n * @param  {string}              postPart - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @return {string}                       - [description]\n */\nfunction optimizePart (prePart, current, postPart, elements, select) {\n  if (prePart.length) prePart = `${prePart} `\n  if (postPart.length) postPart = ` ${postPart}`\n\n  // can't optimize jquery expression\n  if (/:contains\\(/.test(current)) {\n    return current\n  }\n\n  // robustness: attribute without value (generalization)\n  if (/\\[*\\]/.test(current)) {\n    const key = current.replace(/=.*$/, ']')\n    var pattern = `${prePart}${key}${postPart}`\n    var matches = select(pattern)\n    if (compareResults(matches, elements)) {\n      current = key\n    } else {\n      // robustness: replace specific key-value with base tag (heuristic)\n      const references = select(`${prePart}${key}`)\n      for (var i = 0, l = references.length; i < l; i++) {\n        const reference = references[i]\n        if (elements.some((element) => reference.contains(element))) {\n          const description = reference.tagName.toLowerCase()\n          var pattern2 = `${prePart}${description}${postPart}`\n          var matches2 = select(pattern2)\n          if (compareResults(matches2, elements)) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  // robustness: descendant instead child (heuristic)\n  if (/>/.test(current)) {\n    const descendant = current.replace(/>/, '')\n    var pattern3 = `${prePart}${descendant}${postPart}`\n    var matches3 = select(pattern3)\n    if (compareResults(matches3, elements)) {\n      current = descendant\n    }\n  }\n\n  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n  if (/:nth-child/.test(current)) {\n    // TODO: consider complete coverage of 'nth-of-type' replacement\n    const type = current.replace(/nth-child/g, 'nth-of-type')\n    var pattern4 = `${prePart}${type}${postPart}`\n    var matches4 = select(pattern4)\n    if (compareResults(matches4, elements)) {\n      current = type\n    }\n  }\n\n  // efficiency: combinations of classname (partial permutations)\n  if (/^\\.\\S*[^\\s\\\\]\\.\\S+/.test(current)) {\n    var names = current.trim()\n      .replace(/(^|[^\\\\])\\./g, '$1#.') // escape actual dots\n      .split('#.') // split only on actual dots\n      .slice(1)\n      .map((name) => `.${name}`)\n      .sort((curr, next) => curr.length - next.length)\n    while (names.length) {\n      const partial = current.replace(names.shift(), '').trim()\n      var pattern5 = `${prePart}${partial}${postPart}`.trim()\n      if (!pattern5.length || pattern5.charAt(0) === '>' || pattern5.charAt(pattern5.length-1) === '>') {\n        break\n      }\n      var matches5 = select(pattern5)\n      if (compareResults(matches5, elements)) {\n        current = partial\n      }\n    }\n\n    // robustness: degrade complex classname (heuristic)\n    names = current && current.match(/\\./g)\n    if (names && names.length > 2) {\n      const references = select(`${prePart}${current}`)\n      for (var i2 = 0, l2 = references.length; i2 < l2; i2++) {\n        const reference = references[i2]\n        if (elements.some((element) => reference.contains(element) )) {\n          // TODO:\n          // - check using attributes + regard excludes\n          const description = reference.tagName.toLowerCase()\n          var pattern6 = `${prePart}${description}${postPart}`\n          var matches6 = select(pattern6)\n          if (compareResults(matches6, elements)) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return current\n}\n\n/**\n * Evaluate matches with expected elements\n *\n * @param  {Array.<HTMLElement>} matches  - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Boolean}                      - [description]\n */\nfunction compareResults (matches, elements) {\n  const { length } = matches\n  return length === elements.length && elements.every((element) => {\n    for (var i = 0; i < length; i++) {\n      if (matches[i] === element) {\n        return true\n      }\n    }\n    return false\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/optimize.js","/**\n * # Adapt\n *\n * Check and extend the environment for universal usage.\n */\n\n/**\n * Modify the context based on the environment\n *\n * @param  {HTMLELement} element - [description]\n * @param  {Object}      options - [description]\n * @return {boolean}             - [description]\n */\nexport default function adapt (element, options) {\n  // detect environment setup\n  if (global.document) {\n    return false\n  } else {\n    global.document = options.context || (() => {\n      var root = element\n      while (root.parent) {\n        root = root.parent\n      }\n      return root\n    })()\n  }\n\n  // https://github.com/fb55/domhandler/blob/master/index.js#L75\n  const ElementPrototype = Object.getPrototypeOf(global.document)\n\n  // alternative descriptor to access elements with filtering invalid elements (e.g. textnodes)\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'childTags')) {\n    Object.defineProperty(ElementPrototype, 'childTags', {\n      enumerable: true,\n      get () {\n        return this.children.filter((node) => {\n          // https://github.com/fb55/domelementtype/blob/master/index.js#L12\n          return node.type === 'tag' || node.type === 'script' || node.type === 'style'\n        })\n      }\n    })\n  }\n\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'attributes')) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes\n    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap\n    Object.defineProperty(ElementPrototype, 'attributes', {\n      enumerable: true,\n      get () {\n        const { attribs } = this\n        const attributesNames = Object.keys(attribs)\n        const NamedNodeMap = attributesNames.reduce((attributes, attributeName, index) => {\n          attributes[index] = {\n            name: attributeName,\n            value: attribs[attributeName]\n          }\n          return attributes\n        }, { })\n        Object.defineProperty(NamedNodeMap, 'length', {\n          enumerable: false,\n          configurable: false,\n          value: attributesNames.length\n        })\n        return NamedNodeMap\n      }\n    })\n  }\n\n  if (!ElementPrototype.getAttribute) {\n    // https://docs.webplatform.org/wiki/dom/Element/getAttribute\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute\n    ElementPrototype.getAttribute = function (name) {\n      return this.attribs[name] || null\n    }\n  }\n\n  if (!ElementPrototype.getElementsByTagName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByTagName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\n    ElementPrototype.getElementsByTagName = function (tagName) {\n      const HTMLCollection = []\n      traverseDescendants(this.childTags, (descendant) => {\n        if (descendant.name === tagName || tagName === '*') {\n          HTMLCollection.push(descendant)\n        }\n      })\n      return HTMLCollection\n    }\n  }\n\n  if (!ElementPrototype.getElementsByClassName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByClassName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\n    ElementPrototype.getElementsByClassName = function (className) {\n      const names = className.trim().replace(/\\s+/g, ' ').split(' ')\n      const HTMLCollection = []\n      traverseDescendants([this], (descendant) => {\n        const descendantClassName = descendant.attribs.class\n        if (descendantClassName && names.every((name) => descendantClassName.indexOf(name) > -1)) {\n          HTMLCollection.push(descendant)\n        }\n      })\n      return HTMLCollection\n    }\n  }\n\n  if (!ElementPrototype.querySelectorAll) {\n    // https://docs.webplatform.org/wiki/css/selectors_api/querySelectorAll\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll\n    ElementPrototype.querySelectorAll = function (selectors) {\n      selectors = selectors.replace(/(>)(\\S)/g, '$1 $2').trim() // add space for '>' selector\n\n      // using right to left execution => https://github.com/fb55/css-select#how-does-it-work\n      const instructions = getInstructions(selectors)\n      const discover = instructions.shift()\n\n      const total = instructions.length\n      return discover(this).filter((node) => {\n        var step = 0\n        while (step < total) {\n          node = instructions[step](node, this)\n          if (!node) { // hierarchy doesn't match\n            return false\n          }\n          step += 1\n        }\n        return true\n      })\n    }\n  }\n\n  if (!ElementPrototype.contains) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\n    ElementPrototype.contains = function (element) {\n      var inclusive = false\n      traverseDescendants([this], (descendant, done) => {\n        if (descendant === element) {\n          inclusive = true\n          done()\n        }\n      })\n      return inclusive\n    }\n  }\n\n  return true\n}\n\n/**\n * Retrieve transformation steps\n *\n * @param  {Array.<string>}   selectors - [description]\n * @return {Array.<Function>}           - [description]\n */\nfunction getInstructions (selectors) {\n  return selectors.split(' ').reverse().map((selector, step) => {\n    const discover = step === 0\n    const [type, pseudo] = selector.split(':')\n\n    var validate = null\n    var instruction = null\n\n    switch (true) {\n\n      // child: '>'\n      case />/.test(type):\n        instruction = function checkParent (node) {\n          return (validate) => validate(node.parent) && node.parent\n        }\n        break\n\n        // class: '.'\n      case /^\\./.test(type): {\n        const names = type.substr(1).split('.')\n        validate = (node) => {\n          const nodeClassName = node.attribs.class\n          return nodeClassName && names.every((name) => nodeClassName.indexOf(name) > -1)\n        }\n        instruction = function checkClass (node, root) {\n          if (discover) {\n            return node.getElementsByClassName(names.join(' '))\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n      }\n\n      // attribute: '[key=\"value\"]'\n      case /^\\[/.test(type): {\n        const [attributeKey, attributeValue] = type.replace(/\\[|\\]|\"/g, '').split('=')\n        validate = (node) => {\n          const hasAttribute = Object.keys(node.attribs).indexOf(attributeKey) > -1\n          if (hasAttribute) { // regard optional attributeValue\n            if (!attributeValue || (node.attribs[attributeKey] === attributeValue)) {\n              return true\n            }\n          }\n          return false\n        }\n        instruction = function checkAttribute (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n      }\n\n      // id: '#'\n      case /^#/.test(type): {\n        const id = type.substr(1)\n        validate = (node) => {\n          return node.attribs.id === id\n        }\n        instruction = function checkId (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant, done) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n                done()\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n      }\n\n      // universal: '*'\n      case /\\*/.test(type): {\n        validate = () => true\n        instruction = function checkUniversal (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => NodeList.push(descendant))\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n      }\n\n      // tag: '...'\n      default:\n        validate = (node) => {\n          return node.name === type\n        }\n        instruction = function checkTag (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n    }\n\n    if (!pseudo) {\n      return instruction\n    }\n\n    const rule = pseudo.match(/-(child|type)\\((\\d+)\\)$/)\n    const kind = rule[1]\n    const index = parseInt(rule[2], 10) - 1\n\n    const validatePseudo = (node) => {\n      if (node) {\n        var compareSet = node.parent.childTags\n        if (kind === 'type') {\n          compareSet = compareSet.filter(validate)\n        }\n        const nodeIndex = compareSet.findIndex((child) => child === node)\n        if (nodeIndex === index) {\n          return true\n        }\n      }\n      return false\n    }\n\n    return function enhanceInstruction (node) {\n      const match = instruction(node)\n      if (discover) {\n        return match.reduce((NodeList, matchedNode) => {\n          if (validatePseudo(matchedNode)) {\n            NodeList.push(matchedNode)\n          }\n          return NodeList\n        }, [])\n      }\n      return validatePseudo(match) && match\n    }\n  })\n}\n\n/**\n * Walking recursive to invoke callbacks\n *\n * @param {Array.<HTMLElement>} nodes   - [description]\n * @param {Function}            handler - [description]\n */\nfunction traverseDescendants (nodes, handler) {\n  nodes.forEach((node) => {\n    var progress = true\n    handler(node, () => progress = false)\n    if (node.childTags && progress) {\n      traverseDescendants(node.childTags, handler)\n    }\n  })\n}\n\n/**\n * Bubble up from bottom to top\n *\n * @param  {HTMLELement} node     - [description]\n * @param  {HTMLELement} root     - [description]\n * @param  {Function}    validate - [description]\n * @return {HTMLELement}          - [description]\n */\nfunction getAncestor (node, root, validate) {\n  while (node.parent) {\n    node = node.parent\n    if (validate(node)) {\n      return node\n    }\n    if (node === root) {\n      break\n    }\n  }\n  return null\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/adapt.js","/**\n * # Select\n *\n * Construct a unique CSS query selector to access the selected DOM element(s).\n * For longevity it applies different matching and optimization strategies.\n */\nimport css2xpath from 'css2xpath'\n\nimport adapt from './adapt'\nimport match from './match'\nimport optimize from './optimize'\nimport { convertNodeList } from './utilities'\nimport { getSelect, getCommonAncestor, getCommonProperties } from './common'\n\n/**\n * Get a selector for the provided element\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      options - [description]\n * @return {string}              - [description]\n */\nexport function getSingleSelector (element, options = {}) {\n\n  if (element.nodeType === 3) {\n    element = element.parentNode\n  }\n\n  if (element.nodeType !== 1) {\n    throw new Error(`Invalid input - only HTMLElements or representations of them are supported! (not \"${typeof element}\")`)\n  }\n\n  const globalModified = adapt(element, options)\n\n  const selector = match(element, options)\n  const optimized = optimize(selector, element, options)\n\n  // debug\n  // console.log(`\n  //   selector:  ${selector}\n  //   optimized: ${optimized}\n  // `)\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return optimized\n}\n\n/**\n * Get a selector to match multiple descendants from an ancestor\n *\n * @param  {Array.<HTMLElement>|NodeList} elements - [description]\n * @param  {Object}                       options  - [description]\n * @return {string}                                - [description]\n */\nexport function getMultiSelector (elements, options = {}) {\n\n  if (!Array.isArray(elements)) {\n    elements = convertNodeList(elements)\n  }\n\n  if (elements.some((element) => element.nodeType !== 1)) {\n    throw new Error('Invalid input - only an Array of HTMLElements or representations of them is supported!')\n  }\n\n  const globalModified = adapt(elements[0], options)\n  const select = getSelect(options)\n\n  const ancestor = getCommonAncestor(elements, options)\n  const ancestorSelector = getSingleSelector(ancestor, options)\n\n  // TODO: consider usage of multiple selectors + parent-child relation + check for part redundancy\n  const commonSelectors = getCommonSelectors(elements)\n  const descendantSelector = commonSelectors[0]\n\n  const selector = optimize(`${ancestorSelector} ${descendantSelector}`, elements, options)\n  const selectorMatches = convertNodeList(select(selector))\n\n  if (!elements.every((element) => selectorMatches.some((entry) => entry === element) )) {\n    // TODO: cluster matches to split into similar groups for sub selections\n    return console.warn(`\n      The selected elements can't be efficiently mapped.\n      Its probably best to use multiple single selectors instead!\n    `, elements)\n  }\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return selector\n}\n\n/**\n * Get selectors to describe a set of elements\n *\n * @param  {Array.<HTMLElements>} elements - [description]\n * @return {string}                        - [description]\n */\nfunction getCommonSelectors (elements) {\n\n  const { classes, attributes, tag } = getCommonProperties(elements)\n\n  const selectorPath = []\n\n  if (tag) {\n    selectorPath.push(tag)\n  }\n\n  if (classes) {\n    const classSelector = classes.map((name) => `.${name}`).join('')\n    selectorPath.push(classSelector)\n  }\n\n  if (attributes) {\n    const attributeSelector = Object.keys(attributes).reduce((parts, name) => {\n      parts.push(`[${name}=\"${attributes[name]}\"]`)\n      return parts\n    }, []).join('')\n    selectorPath.push(attributeSelector)\n  }\n\n  if (selectorPath.length) {\n    // TODO: check for parent-child relation\n  }\n\n  return [\n    selectorPath.join('')\n  ]\n}\n\n/**\n * Choose action depending on the input (multiple/single)\n *\n * NOTE: extended detection is used for special cases like the <select> element with <options>\n *\n * @param  {HTMLElement|NodeList|Array.<HTMLElement>} input   - [description]\n * @param  {Object}                                   options - [description]\n * @return {string}                                           - [description]\n */\nexport default function getQuerySelector (input, options = {}) {\n  if (input.length && !input.name) {\n    return getMultiSelector(input, options)\n  }\n  const result = getSingleSelector(input, options)\n  if (options && [1, 'xpath'].includes(options.format)) {\n    return css2xpath(result)\n  }\n\n  return result\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/select.js","'use strict';\n\n(function () {\n  var xpath_to_lower         = function (s) {\n        return 'translate(' +\n                (s || 'normalize-space()') +\n                ', \\'ABCDEFGHJIKLMNOPQRSTUVWXYZ\\'' +\n                ', \\'abcdefghjiklmnopqrstuvwxyz\\')';\n      },\n      xpath_ends_with        = function (s1, s2) {\n        return 'substring(' + s1 + ',' +\n                'string-length(' + s1 + ')-string-length(' + s2 + ')+1)=' + s2;\n      },\n      xpath_url              = function (s) {\n        return 'substring-before(concat(substring-after(' +\n                (s || xpath_url_attrs) + ',\"://\"),\"?\"),\"?\")';\n      },\n      xpath_url_path         = function (s) {\n        return 'substring-after(' + (s || xpath_url_attrs) + ',\"/\")';\n      },\n      xpath_url_domain       = function (s) {\n        return 'substring-before(concat(substring-after(' +\n               (s || xpath_url_attrs) + ',\"://\"),\"/\"),\"/\")';\n      },\n      xpath_url_attrs        = '@href|@src',\n      xpath_lower_case       = xpath_to_lower(),\n      xpath_ns_uri           = 'ancestor-or-self::*[last()]/@url',\n      xpath_ns_path          = xpath_url_path(xpath_url(xpath_ns_uri)),\n      xpath_has_protocal     = '(starts-with(' + xpath_url_attrs + ',\"http://\") or starts-with(' + xpath_url_attrs + ',\"https://\"))',\n      xpath_is_internal      = 'starts-with(' + xpath_url() + ',' + xpath_url_domain(xpath_ns_uri) + ') or ' + xpath_ends_with(xpath_url_domain(), xpath_url_domain(xpath_ns_uri)),\n      xpath_is_local         = '(' + xpath_has_protocal + ' and starts-with(' + xpath_url() + ',' + xpath_url(xpath_ns_uri) + '))',\n      xpath_is_path          = 'starts-with(' + xpath_url_attrs + ',\"/\")',\n      xpath_is_local_path    = 'starts-with(' + xpath_url_path() + ',' + xpath_ns_path + ')',\n      xpath_normalize_space  = 'normalize-space()',\n      xpath_internal         = '[not(' + xpath_has_protocal + ') or ' + xpath_is_internal + ']',\n      xpath_external         = '[' + xpath_has_protocal + ' and not(' + xpath_is_internal + ')]',\n      escape_literal         = String.fromCharCode(30),\n      escape_parens          = String.fromCharCode(31),\n      regex_string_literal   = /(\"[^\"\\x1E]*\"|'[^'\\x1E]*'|=\\s*[^\\s\\]\\'\\\"]+)/g,\n      regex_escaped_literal  = /['\"]?(\\x1E+)['\"]?/g,\n      regex_css_wrap_pseudo  = /(\\x1F\\)|[^\\)])\\:(first|limit|last|gt|lt|eq|nth)([^\\-]|$)/,\n      regex_specal_chars     = /[\\x1C-\\x1F]+/g,\n      regex_first_axis       = /^([\\s\\(\\x1F]*)(\\.?[^\\.\\/\\(]{1,2}[a-z]*:*)/,\n      regex_filter_prefix    = /(^|\\/|\\:)\\[/g,\n      regex_attr_prefix      = /([^\\(\\[\\/\\|\\s\\x1F])\\@/g,\n      regex_nth_equation     = /^([-0-9]*)n.*?([0-9]*)$/,\n      css_combinators_regex  = /\\s*(!?[+>~,^ ])\\s*(\\.?\\/+|[a-z\\-]+::)?([a-z\\-]+\\()?((and\\s*|or\\s*|mod\\s*)?[^+>~,\\s'\"\\]\\|\\^\\$\\!\\<\\=\\x1C-\\x1F]+)?/g,\n      css_combinators_callback = function (match, operator, axis, func, literal, exclude, offset, orig) {\n        var prefix = ''; // If we can, we'll prefix a '.'\n\n        // XPath operators can look like node-name selectors\n        // Detect false positive for \" and\", \" or\", \" mod\"\n        if (operator === ' ' && exclude !== undefined) {\n          return match;\n        }\n\n        if (axis === undefined) {\n          // Only allow node-selecting XPath functions\n          // Detect false positive for \" + count(...)\", \" count(...)\", \" > position()\", etc.\n          if (func !== undefined && (func !== 'node(' && func !== 'text(' && func !== 'comment('))                {\n            return;\n          } else if (literal === undefined) {\n            literal = func;\n          } // Handle case \" + text()\", \" > comment()\", etc. where \"func\" is our \"literal\"\n\n            // XPath math operators match some CSS combinators\n            // Detect false positive for \" + 1\", \" > 1\", etc.\n          if (isNumeric(literal)) {\n            return match;\n          }\n\n          var prevChar = orig.charAt(offset - 1);\n\n          if (prevChar.length === 0 ||\n                prevChar === '(' ||\n                prevChar === '|' ||\n                prevChar === ':') {\n            prefix = '.';\n          }\n        }\n\n        // Return if we don't have a selector to follow the axis\n        if (literal === undefined) {\n          if (offset + match.length === orig.length) {\n            literal = '*';\n          } else {\n            return match;\n          }\n        }\n\n\n        switch (operator) {\n        case ' ':\n          return '//' + literal;\n        case '>':\n          return '/' + literal;\n        case '+':\n          return prefix + '/following-sibling::*[1]/self::' + literal;\n        case '~':\n          return prefix + '/following-sibling::' + literal;\n        case ',':\n          if (axis === undefined) {\n\n          }\n          axis = './/';\n          return '|' + axis + literal;\n        case '^': // first child\n          return '/child::*[1]/self::' + literal;\n        case '!^': // last child\n          return '/child::*[last()]/self::' + literal;\n        case '! ': // ancestor-or-self\n          return '/ancestor-or-self::' + literal;\n        case '!>': // direct parent\n          return '/parent::' + literal;\n        case '!+': // adjacent preceding sibling\n          return '/preceding-sibling::*[1]/self::' + literal;\n        case '!~': // preceding sibling\n          return '/preceding-sibling::' + literal;\n            // case '~~'\n            // return '/following-sibling::*/self::|'+selectorStart(orig, offset)+'/preceding-sibling::*/self::'+literal;\n        }\n      },\n\n      css_attributes_regex = /\\[([^\\@\\|\\*\\=\\^\\~\\$\\!\\(\\/\\s\\x1C-\\x1F]+)\\s*(([\\|\\*\\~\\^\\$\\!]?)=?\\s*(\\x1E+))?\\]/g,\n      css_attributes_callback = function (str, attr, comp, op, val, offset, orig) {\n        var axis = '';\n        var prevChar = orig.charAt(offset - 1);\n\n        /*\n        if (prevChar === '/' || // found after an axis shortcut (\"/\", \"//\", etc.)\n            prevChar === ':')   // found after an axis (\"self::\", \"parent::\", etc.)\n            axis = '*';*/\n\n        switch (op) {\n        case '!':\n          return axis + '[not(@' + attr + ') or @' + attr + '!=\"' + val + '\"]';\n        case '$':\n          return axis + '[substring(@' + attr + ',string-length(@' + attr + ')-(string-length(\"' + val + '\")-1))=\"' + val + '\"]';\n        case '^':\n          return axis + '[starts-with(@' + attr + ',\"' + val + '\")]';\n        case '~':\n          return axis + '[contains(concat(\" \",normalize-space(@' + attr + '),\" \"),concat(\" \",\"' + val + '\",\" \"))]';\n        case '*':\n          return axis + '[contains(@' + attr + ',\"' + val + '\")]';\n        case '|':\n          return axis + '[@' + attr + '=\"' + val + '\" or starts-with(@' + attr + ',concat(\"' + val + '\",\"-\"))]';\n        default:\n          if (comp === undefined) {\n            if (attr.charAt(attr.length - 1) === '(' || attr.search(/^[0-9]+$/) !== -1 || attr.indexOf(':') !== -1)                        {\n              return str;\n            }\n            return axis + '[@' + attr + ']';\n          } else {\n            return axis + '[@' + attr + '=\"' + val + '\"]';\n          }\n        }\n      },\n\n      css_pseudo_classes_regex = /:([a-z\\-]+)(\\((\\x1F+)(([^\\x1F]+(\\3\\x1F+)?)*)(\\3\\)))?/g,\n      css_pseudo_classes_callback = function (match, name, g1, g2, arg, g3, g4, g5, offset, orig) {\n        if (orig.charAt(offset - 1) === ':' && orig.charAt(offset - 2) !== ':') {\n            // XPath \"axis::node-name\" will match\n            // Detect false positive \":node-name\"\n          return match;\n        }\n\n        if (name === 'odd' || name === 'even') {\n          arg  = name;\n          name = 'nth-of-type';\n        }\n\n        switch (name) { // name.toLowerCase()?\n        case 'after':\n          return '[count(' + css2xpath('preceding::' + arg, true) + ') > 0]';\n        case 'after-sibling':\n          return '[count(' + css2xpath('preceding-sibling::' + arg, true) + ') > 0]';\n        case 'before':\n          return '[count(' + css2xpath('following::' + arg, true) + ') > 0]';\n        case 'before-sibling':\n          return '[count(' + css2xpath('following-sibling::' + arg, true) + ') > 0]';\n        case 'checked':\n          return '[@selected or @checked]';\n        case 'contains':\n          return '[contains(' + xpath_normalize_space + ',' + arg + ')]';\n        case 'icontains':\n          return '[contains(' + xpath_lower_case + ',' + xpath_to_lower(arg) + ')]';\n        case 'empty':\n          return '[not(*) and not(normalize-space())]';\n        case 'enabled':\n        case 'disabled':\n          return '[@' + name + ']';\n        case 'first-child':\n          return '[not(preceding-sibling::*)]';\n        case 'first':\n        case 'limit':\n        case 'first-of-type':\n          if (arg !== undefined)                    {\n            return '[position()<=' + arg + ']';\n          }\n          return '[1]';\n        case 'gt':\n                // Position starts at 0 for consistency with Sizzle selectors\n          return '[position()>' + (parseInt(arg, 10) + 1) + ']';\n        case 'lt':\n                // Position starts at 0 for consistency with Sizzle selectors\n          return '[position()<' + (parseInt(arg, 10) + 1) + ']';\n        case 'last-child':\n          return '[not(following-sibling::*)]';\n        case 'only-child':\n          return '[not(preceding-sibling::*) and not(following-sibling::*)]';\n        case 'only-of-type':\n          return '[not(preceding-sibling::*[name()=name(self::node())]) and not(following-sibling::*[name()=name(self::node())])]';\n        case 'nth-child':\n          if (isNumeric(arg))                    {\n            return '[(count(preceding-sibling::*)+1) = ' + arg + ']';\n          }\n          switch (arg) {\n          case 'even':\n            return '[(count(preceding-sibling::*)+1) mod 2=0]';\n          case 'odd':\n            return '[(count(preceding-sibling::*)+1) mod 2=1]';\n          default:\n            var a = (arg || '0').replace(regex_nth_equation, '$1+$2').split('+');\n\n            a[0] = a[0] || '1';\n            a[1] = a[1] || '0';\n            return '[(count(preceding-sibling::*)+1)>=' + a[1] + ' and ((count(preceding-sibling::*)+1)-' + a[1] + ') mod ' + a[0] + '=0]';\n          }\n        case 'nth-of-type':\n          if (isNumeric(arg))                    {\n            return '[' + arg + ']';\n          }\n          switch (arg) {\n          case 'odd':\n            return '[position() mod 2=1]';\n          case 'even':\n            return '[position() mod 2=0 and position()>=0]';\n          default:\n            var a = (arg || '0').replace(regex_nth_equation, '$1+$2').split('+');\n\n            a[0] = a[0] || '1';\n            a[1] = a[1] || '0';\n            return '[position()>=' + a[1] + ' and (position()-' + a[1] + ') mod ' + a[0] + '=0]';\n          }\n        case 'eq':\n        case 'nth':\n          // Position starts at 0 for consistency with Sizzle selectors\n          if (isNumeric(arg)) {\n            return '[' + (parseInt(arg, 10) + 1) + ']';\n          }\n\n          return '[1]';\n        case 'text':\n          return '[@type=\"text\"]';\n        case 'istarts-with':\n          return '[starts-with(' + xpath_lower_case + ',' + xpath_to_lower(arg) + ')]';\n        case 'starts-with':\n          return '[starts-with(' + xpath_normalize_space + ',' + arg + ')]';\n        case 'iends-with':\n          return '[' + xpath_ends_with(xpath_lower_case, xpath_to_lower(arg)) + ']';\n        case 'ends-with':\n          return '[' + xpath_ends_with(xpath_normalize_space, arg) + ']';\n        case 'has':\n          var xpath = prependAxis(css2xpath(arg, true), './/');\n\n          return '[count(' + xpath + ') > 0]';\n        case 'has-sibling':\n          var xpath = css2xpath('preceding-sibling::' + arg, true);\n\n          return '[count(' + xpath + ') > 0 or count(following-sibling::' + xpath.substr(19) + ') > 0]';\n        case 'has-parent':\n          return '[count(' + css2xpath('parent::' + arg, true) + ') > 0]';\n        case 'has-ancestor':\n          return '[count(' + css2xpath('ancestor::' + arg, true) + ') > 0]';\n        case 'last':\n        case 'last-of-type':\n          if (arg !== undefined)                    {\n            return '[position()>last()-' + arg + ']';\n          }\n          return '[last()]';\n        case 'selected': // Sizzle: \"(option) elements that are currently selected\"\n          return '[local-name()=\"option\" and @selected]';\n        case 'skip':\n        case 'skip-first':\n          return '[position()>' + arg + ']';\n        case 'skip-last':\n          if (arg !== undefined)                    {\n            return '[last()-position()>=' + arg + ']';\n          }\n          return '[position()<last()]';\n        case 'root':\n          return '/ancestor::[last()]';\n        case 'range':\n          var arr = arg.split(',');\n\n          return '[' + arr[0] + '<=position() and position()<=' + arr[1] + ']';\n        case 'input': // Sizzle: \"input, button, select, and textarea are all considered to be input elements.\"\n          return '[local-name()=\"input\" or local-name()=\"button\" or local-name()=\"select\" or local-name()=\"textarea\"]';\n        case 'internal':\n          return xpath_internal;\n        case 'external':\n          return xpath_external;\n        case 'http':\n        case 'https':\n        case 'mailto':\n        case 'javascript':\n          return '[starts-with(@href,concat(\"' + name + '\",\":\"))]';\n        case 'domain':\n          return '[(string-length(' + xpath_url_domain() + ')=0 and contains(' + xpath_url_domain(xpath_ns_uri) + ',' + arg + ')) or contains(' + xpath_url_domain() + ',' + arg + ')]';\n        case 'path':\n          return '[starts-with(' + xpath_url_path() + ',substring-after(\"' + arg + '\",\"/\"))]'\n        case 'not':\n          var xpath = css2xpath(arg, true);\n\n          if (xpath.charAt(0) === '[')                    {\n            xpath = 'self::node()' + xpath;\n          }\n          return '[not(' + xpath + ')]';\n        case 'target':\n          return '[starts-with(@href, \"#\")]';\n        case 'root':\n          return 'ancestor-or-self::*[last()]';\n            /* case 'active':\n            case 'focus':\n            case 'hover':\n            case 'link':\n            case 'visited':\n                return '';*/\n        case 'lang':\n          return '[@lang=\"' + arg + '\"]';\n        case 'read-only':\n        case 'read-write':\n          return '[@' + name.replace('-', '') + ']';\n        case 'valid':\n        case 'required':\n        case 'in-range':\n        case 'out-of-range':\n          return '[@' + name + ']';\n        default:\n          return match;\n        }\n      },\n\n      css_ids_classes_regex = /(#|\\.)([^\\#\\@\\.\\/\\(\\[\\)\\]\\|\\:\\s\\+\\>\\<\\'\\\"\\x1D-\\x1F]+)/g,\n      css_ids_classes_callback = function (str, op, val, offset, orig) {\n        var axis = '';\n        /* var prevChar = orig.charAt(offset-1);\n        if (prevChar.length === 0 ||\n            prevChar === '/' ||\n            prevChar === '(')\n            axis = '*';\n        else if (prevChar === ':')\n            axis = 'node()';*/\n        if (op === '#')            {\n          return axis + '[@id=\"' + val + '\"]';\n        }\n        return axis + '[contains(concat(\" \",normalize-space(@class),\" \"),\" ' + val + ' \")]';\n      };\n\n    // Prepend descendant-or-self if no other axis is specified\n  function prependAxis(s, axis) {\n    return s.replace(regex_first_axis, function (match, start, literal) {\n      if (literal.substr(literal.length - 2) === '::') // Already has axis::\n            {\n        return match;\n      }\n\n      if (literal.charAt(0) === '[')            {\n        axis += '*';\n      }\n        // else if (axis.charAt(axis.length-1) === ')')\n        //    axis += '/';\n      return start + axis + literal;\n    });\n  }\n\n    // Find the begining of the selector, starting at i and working backwards\n  function selectorStart(s, i) {\n    var depth = 0;\n    var offset = 0;\n\n    while (i--) {\n      switch (s.charAt(i)) {\n      case ' ':\n      case escape_parens:\n        offset++;\n        break;\n      case '[':\n      case '(':\n        depth--;\n\n        if (depth < 0)                    {\n          return ++i + offset;\n        }\n        break;\n      case ']':\n      case ')':\n        depth++;\n        break;\n      case ',':\n      case '|':\n        if (depth === 0)                    {\n          return ++i + offset;\n        }\n      default:\n        offset = 0;\n      }\n    }\n\n    return 0;\n  }\n\n    // Check if string is numeric\n  function isNumeric(s) {\n    var num = parseInt(s, 10);\n\n    return (!isNaN(num) && '' + num === s);\n  }\n\n    // Append escape \"char\" to \"open\" or \"close\"\n  function escapeChar(s, open, close, char) {\n    var depth = 0;\n\n    return s.replace(new RegExp('[\\\\' + open + '\\\\' + close + ']', 'g'), function (a) {\n      if (a === open)            {\n        depth++;\n      }\n\n      if (a === open) {\n        return a + repeat(char, depth);\n      } else {\n        return repeat(char, depth--) + a;\n      }\n    })\n  }\n\n  function repeat(str, num) {\n    num = Number(num);\n    var result = '';\n\n    while (true) {\n      if (num & 1)            {\n        result += str;\n      }\n      num >>>= 1;\n\n      if (num <= 0) {\n        break;\n      }\n      str += str;\n    }\n\n    return result;\n  }\n\n  function convertEscaping (value) {\n    return value && value.replace(/\\\\([`\\\\/:\\?&!#$%^()[\\]{|}*+;,.<=>@~])/g, '$1')\n      .replace(/\\\\(['\"])/g, '$1$1')\n      .replace(/\\\\A /g, '\\n')\n  }\n\n  function css2xpath(s, nested) {\n    // s = s.trim();\n\n    if (nested === true) {\n        // Replace :pseudo-classes\n      s = s.replace(css_pseudo_classes_regex, css_pseudo_classes_callback);\n\n        // Replace #ids and .classes\n      s = s.replace(css_ids_classes_regex, css_ids_classes_callback);\n\n      return s;\n    }\n\n    // Tag open and close parenthesis pairs (for RegExp searches)\n    s = escapeChar(s, '(', ')', escape_parens);\n\n    // Remove and save any string literals\n    var literals = [];\n\n    s = s.replace(regex_string_literal, function (s, a) {\n      if (a.charAt(0) === '=') {\n        a = a.substr(1).trim();\n\n        if (isNumeric(a))                {\n          return s;\n        }\n      } else {\n        a = a.substr(1, a.length - 2);\n      }\n\n      return repeat(escape_literal, literals.push(convertEscaping(a)));\n    });\n\n    // Replace CSS combinators (\" \", \"+\", \">\", \"~\", \",\") and reverse combinators (\"!\", \"!+\", \"!>\", \"!~\")\n    s = s.replace(css_combinators_regex, css_combinators_callback);\n\n    // Replace CSS attribute filters\n    s = s.replace(css_attributes_regex, css_attributes_callback);\n\n    // Wrap certain :pseudo-classes in parens (to collect node-sets)\n    while (true) {\n      var index = s.search(regex_css_wrap_pseudo);\n\n      if (index === -1) {\n        break;\n      }\n      index = s.indexOf(':', index);\n      var start = selectorStart(s, index);\n\n      s = s.substr(0, start) +\n            '(' + s.substring(start, index) + ')' +\n            s.substr(index);\n    }\n\n    // Replace :pseudo-classes\n    s = s.replace(css_pseudo_classes_regex, css_pseudo_classes_callback);\n\n    // Replace #ids and .classes\n    s = s.replace(css_ids_classes_regex, css_ids_classes_callback);\n\n    // Restore the saved string literals\n    s = s.replace(regex_escaped_literal, function (s, a) {\n      var str = literals[a.length - 1];\n\n      return '\"' + str + '\"';\n    })\n\n    // Remove any special characters\n    s = s.replace(regex_specal_chars, '');\n\n    // add * to stand-alone filters\n    s = s.replace(regex_filter_prefix, '$1*[');\n\n    // add \"/\" between @attribute selectors\n    s = s.replace(regex_attr_prefix, '$1/@');\n\n    /*\n    Combine multiple filters?\n\n    s = escapeChar(s, '[', ']', filter_char);\n    s = s.replace(/(\\x1D+)\\]\\[\\1(.+?[^\\x1D])\\1\\]/g, ' and ($2)$1]')\n    */\n\n    s = prependAxis(s, './/'); // prepend \".//\" axis to begining of CSS selector\n    return s;\n  }\n\n\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = css2xpath;\n  } else {\n    window.css2xpath = css2xpath;\n  }\n\n})();\n\n\n\n// WEBPACK FOOTER //\n// ./~/css2xpath/index.js","/*!\n * Sizzle CSS Selector Engine v2.3.6\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2021-02-16\n */\n( function( window ) {\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ( {} ).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpushNative = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t\t// \"Attribute values must be CSS identifiers [capture 5]\n\t\t// or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n\t\twhitespace + \"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n\t\twhitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n\t\t\"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n\tfunescape = function( escape, nonHex ) {\n\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\t\tnonHex :\n\n\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t\t// Support: IE <=11+\n\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t\t// surrogate pair\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n\t\tpreferredDoc.childNodes\n\t);\n\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\t// eslint-disable-next-line no-unused-expressions\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpushNative.apply( target, slice.call( els ) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\t\tsetDocument( context );\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[ 2 ] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 &&\n\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\n\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn ( cache[ key + \" \" ] = value );\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement( \"fieldset\" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch ( e ) {\n\t\treturn false;\n\t} finally {\n\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split( \"|\" ),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( ( cur = cur.nextSibling ) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem && elem.namespaceURI,\n\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( preferredDoc != document &&\n\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n\t// Support: Safari 6.0 only\n\t// Safari 6.0 supports :scope but it's an alias of :root there.\n\tsupport.scope = assert( function( el ) {\n\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n\t} );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert( function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute( \"className\" );\n\t} );\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert( function( el ) {\n\t\tel.appendChild( document.createComment( \"\" ) );\n\t\treturn !el.getElementsByTagName( \"*\" ).length;\n\t} );\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert( function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t} );\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[ \"ID\" ] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode( \"id\" );\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert( function( el ) {\n\n\t\t\tvar input;\n\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"~=\" );\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t// around the issue.\n\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\t\tinput = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"name\", \"\" );\n\t\t\tel.appendChild( input );\n\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n\t\t\t\trbuggyQSA.push( \":checked\" );\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n\t\t\t}\n\n\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n\t\t} );\n\n\t\tassert( function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: Opera 10 - 11 only\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll( \"*,:x\" );\n\t\t\trbuggyQSA.push( \",.*:\" );\n\t\t} );\n\t}\n\n\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector ) ) ) ) {\n\n\t\tassert( function( el ) {\n\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t} );\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t) );\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( ( b = b.parentNode ) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, a ) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, b ) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\treturn a == document ? -1 :\n\t\t\t\tb == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[ i ] === bp[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[ i ] == preferredDoc ? -1 :\n\t\t\tbp[ i ] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\tsetDocument( elem );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( context.ownerDocument || context ) != document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( elem.ownerDocument || elem ) != document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( ( node = elem[ i++ ] ) ) {\n\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[ 2 ] === \"~=\" ) {\n\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n\n\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[ 3 ] ) {\n\t\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[ 3 ] ) {\n\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n\n\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[ 3 ] ) {\n\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn true;\n\t\t\t\t} :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n\t\t\t\t\t\tclassName, function( elem ) {\n\t\t\t\t\t\t\treturn pattern.test(\n\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n\t\t\t\t\t\t\t\t\"\"\n\t\t\t\t\t\t\t);\n\t\t\t\t} );\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t\t/* eslint-enable max-len */\n\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction( function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction( function( selector ) {\n\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) :\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tinput[ 0 ] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[ 0 ] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t} ),\n\n\t\t\"has\": markFunction( function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t} ),\n\n\t\t\"contains\": markFunction( function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t} ),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t} ),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement &&\n\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n\t\t\t\t\tattr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo( function() {\n\t\t\treturn [ 0 ];\n\t\t} ),\n\n\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t} ),\n\n\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t} ),\n\n\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} )\n\t}\n};\n\nExpr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n\t\t\tif ( match ) {\n\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( ( tokens = [] ) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[ i ].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[ 0 ];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[ i ], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction( function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(\n\t\t\t\tselector || \"*\",\n\t\t\t\tcontext.nodeType ? [ context ] : context,\n\t\t\t\t[]\n\t\t\t),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n\n\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t} );\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t( checkContext = context ).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens\n\t\t\t\t\t\t.slice( 0, i - 1 )\n\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[ i ] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache(\n\t\t\tselector,\n\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n\t\t);\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[ i ];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( ( seed = find(\n\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext\n\t\t\t\t) ) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert( function( el ) {\n\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n} );\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert( function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n} ) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert( function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n} ) ) {\n\taddHandle( \"value\", function( elem, _name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert( function( el ) {\n\treturn el.getAttribute( \"disabled\" ) == null;\n} ) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t}\n\t} );\n}\n\n// EXPOSE\nvar _sizzle = window.Sizzle;\n\nSizzle.noConflict = function() {\n\tif ( window.Sizzle === Sizzle ) {\n\t\twindow.Sizzle = _sizzle;\n\t}\n\n\treturn Sizzle;\n};\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn Sizzle;\n\t} );\n\n// Sizzle requires that there be a global window in Common-JS like environments\n} else if ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = Sizzle;\n} else {\n\twindow.Sizzle = Sizzle;\n}\n\n// EXPOSE\n\n} )( window );\n\n\n\n// WEBPACK FOOTER //\n// ./~/sizzle/dist/sizzle.js","/**\n * # Match\n *\n * Retrieve selector for a node.\n */\n\nimport { getSelect } from './common'\nimport { escapeValue } from './utilities'\n\nconst defaultIgnore = {\n  attribute (attributeName) {\n    return [\n      'style',\n      'data-reactid',\n      'data-react-checksum'\n    ].indexOf(attributeName) > -1\n  }\n}\n\n/**\n * Get the path of the element\n *\n * @param  {HTMLElement} node    - [description]\n * @param  {Object}      options - [description]\n * @return {string}              - [description]\n */\nexport default function match (node, options) {\n\n  const {\n    root = document,\n    skip = null,\n    priority = ['id', 'class', 'href', 'src'],\n    ignore = {},\n    format\n  } = options\n\n  const path = []\n  var element = node\n  var length = path.length\n  const jquery = (format === 'jquery')\n  const select = getSelect(options)\n\n  const skipCompare = skip && (Array.isArray(skip) ? skip : [skip]).map((entry) => {\n    if (typeof entry !== 'function') {\n      return (element) => element === entry\n    }\n    return entry\n  })\n\n  const skipChecks = (element) => {\n    return skip && skipCompare.some((compare) => compare(element))\n  }\n\n  Object.keys(ignore).forEach((type) => {\n    var predicate = ignore[type]\n    if (typeof predicate === 'function') return\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString()\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp(escapeValue(predicate).replace(/\\\\/g, '\\\\\\\\'))\n    }\n    if (typeof predicate === 'boolean') {\n      predicate = predicate ? /(?:)/ : /.^/\n    }\n    // check class-/attributename for regex\n    ignore[type] = (name, value) => predicate.test(value)\n  })\n\n  while (element !== root && element.nodeType !== 11) {\n    if (skipChecks(element) !== true) {\n      // ~ global\n      if (checkAttributes(priority, element, ignore, path, select, root)) break\n      if (checkTag(element, ignore, path, select, root)) break\n\n      // ~ local\n      checkAttributes(priority, element, ignore, path, select)\n      if (path.length === length) {\n        checkTag(element, ignore, path, select)\n      }\n\n      if (jquery && path.length === length) {\n        checkContains(priority, element, ignore, path, select)\n      }\n\n      // define only one part each iteration\n      if (path.length === length) {\n        checkChilds(priority, element, ignore, path, select)\n      }\n    }\n\n    element = element.parentNode\n    length = path.length\n  }\n\n  if (element === root) {\n    const pattern = findPattern(priority, element, ignore, select)\n    path.unshift(pattern)\n  }\n\n  return path.join(' ')\n}\n\n/**\n * Extend path with attribute identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @param  {HTMLElement}    parent   - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkAttributes (priority, element, ignore, path, select, parent = element.parentNode) {\n  const pattern = findAttributesPattern(priority, element, ignore, select, parent)\n  if (pattern) {\n    const matches = select(pattern, parent)\n    if (matches.length === 1) {\n      path.unshift(pattern)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Get class selector\n *\n * @param  {Array.<string>} classes - [description]\n * @param  {function}       select  - [description]\n * @param  {HTMLElement}    parent  - [description]\n * @return {string?}                - [description]\n */\nfunction getClassSelector(classes = [], select, parent) {\n  let result = [[]]\n\n  classes.forEach(function(c) {\n    result.forEach(function(r) {\n      result.push(r.concat('.' + c))\n    })\n  })\n\n  result.shift()\n\n  result = result.sort(function(a,b) { return a.length - b.length })\n\n  for(let i = 0; i < result.length; i++) {\n    let r = result[i].join('')\n    const matches = select(r, parent)\n    if (matches.length === 1) {\n      return r\n    }\n  }\n\n  return null\n}\n\n/**\n * Lookup attribute identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n\n * @return {string?}                 - [description]\n */\nfunction findAttributesPattern (priority, element, ignore, select, parent = element.parentNode) {\n  const attributes = element.attributes\n  var attributeNames = Object.keys(attributes).map((val) => attributes[val].name)\n    .filter((a) => priority.indexOf(a) < 0)\n\n  var sortedKeys = [ ...priority, ...attributeNames ]\n\n  var tagName = element.tagName.toLowerCase()\n\n  for (var i = 0, l = sortedKeys.length; i < l; i++) {\n    const key = sortedKeys[i]\n    const attribute = attributes[key]\n    const attributeName = escapeValue(attribute && attribute.name)\n    const attributeValue = escapeValue(attribute && attribute.value)\n    const useNamedIgnore = attributeName !== 'class'\n\n    const currentIgnore = (useNamedIgnore && ignore[attributeName]) || ignore.attribute\n    const currentDefaultIgnore = (useNamedIgnore && defaultIgnore[attributeName]) || defaultIgnore.attribute\n    if (checkIgnore(currentIgnore, attributeName, attributeValue, currentDefaultIgnore)) {\n      continue\n    }\n\n    var pattern = `[${attributeName}=\"${attributeValue}\"]`\n    if(!attributeValue.trim()) {\n      return null\n    }\n\n    if (attributeName === 'id') {\n      pattern = `#${attributeValue}`\n    }\n\n    if (attributeName === 'class') {\n      let classNames = attributeValue.trim().split(/\\s+/g)\n      const classIgnore = ignore.class || defaultIgnore.class\n      if (classIgnore) {\n        classNames = classNames.filter(className => !classIgnore(className))\n      }\n      if (classNames.length === 0) {\n        continue\n      }\n      pattern = getClassSelector(classNames, select, parent)\n\n      if (!pattern) {\n        continue\n      }\n    }\n\n    return tagName + pattern\n  }\n  return null\n}\n\n/**\n * Extend path with tag identifier\n *\n * @param  {HTMLElement}    element - [description]\n * @param  {Object}         ignore  - [description]\n * @param  {Array.<string>} path    - [description]\n * @param  {function}       select  - [description]\n * @param  {HTMLElement}    parent  - [description]\n * @return {boolean}                - [description]\n */\nfunction checkTag (element, ignore, path, select, parent = element.parentNode) {\n  const pattern = findTagPattern(element, ignore)\n  if (pattern) {\n    let matches = []\n    matches = select(pattern, parent)\n    if (matches.length === 1) {\n      path.unshift(pattern)\n      if (pattern === 'iframe') {\n        return false\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Lookup tag identifier\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      ignore  - [description]\n * @return {boolean}             - [description]\n */\nfunction findTagPattern (element, ignore) {\n  const tagName = element.tagName.toLowerCase()\n  if (checkIgnore(ignore.tag, null, tagName)) {\n    return null\n  }\n  return tagName\n}\n\n/**\n * Extend path with specific child identifier\n *\n * NOTE: 'childTags' is a custom property to use as a view filter for tags using 'adapter.js'\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkChilds (priority, element, ignore, path, select) {\n  const parent = element.parentNode\n  const children = parent.childTags || parent.children\n  for (var i = 0, l = children.length; i < l; i++) {\n    const child = children[i]\n    if (child === element) {\n      const childPattern = findPattern(priority, child, ignore, select)\n      if (!childPattern) {\n        return console.warn(`\n          Element couldn't be matched through strict ignore pattern!\n        `, child, ignore, childPattern)\n      }\n      const pattern = `> ${childPattern}:nth-child(${i+1})`\n      path.unshift(pattern)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Extend path with contains\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkContains (priority, element, ignore, path, select) {\n  const elementPattern = findPattern(priority, element, ignore, select)\n  const text = element.textContent.trim()\n  if (text.length > 0 && text.indexOf('\\n') < 0) {\n    const parent = element.parentNode\n    const children = parent.childTags || parent.children\n    for (var i = 0, l = children.length; i < l; i++) {\n      const child = children[i]\n      if (child !== element) {\n        if (child.textContent.indexOf(text) > 0) {\n          return false\n        }\n      }\n    }\n    const pattern = `${elementPattern}:contains(\"${text}\")`\n    path.unshift(pattern)\n    return true\n  }\n  return false\n}\n\n/**\n * Lookup identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @return {string}                  - [description]\n */\nfunction findPattern (priority, element, ignore, select) {\n  var pattern = findAttributesPattern(priority, element, ignore, select)\n  if (!pattern) {\n    pattern = findTagPattern(element, ignore)\n  }\n  return pattern\n}\n\n/**\n * Validate with custom and default functions\n *\n * @param  {Function} predicate        - [description]\n * @param  {string?}  name             - [description]\n * @param  {string}   value            - [description]\n * @param  {Function} defaultPredicate - [description]\n * @return {boolean}                   - [description]\n */\nfunction checkIgnore (predicate, name, value, defaultPredicate) {\n  if (!value) {\n    return true\n  }\n  const check = predicate || defaultPredicate\n  if (!check) {\n    return false\n  }\n  return check(name, value, defaultPredicate)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/match.js","export { default as select, getSingleSelector, getMultiSelector } from './select'\nexport { default as optimize } from './optimize'\nexport * as common from './common'\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}